Directory structure:
└── kalepail-passkey-kit/
    ├── README.md
    ├── cheatsheet.txt
    ├── clone-js-sdk.sh
    ├── LICENCE
    ├── package.json
    ├── pnpm-lock.yaml
    ├── pnpm-workspace.yaml
    ├── PROPOSAL.md
    ├── tsconfig.json
    ├── .npmignore
    ├── bun_tests/
    │   ├── README.md
    │   ├── 0.index.ts
    │   ├── 1.index.ts
    │   ├── 2.index.ts
    │   ├── 3.index.ts
    │   ├── 4.index.ts
    │   ├── 5.index.ts
    │   ├── 6.index.ts
    │   ├── 7.index.ts
    │   ├── 8.index.ts
    │   ├── package.json
    │   └── tsconfig.json
    ├── contracts/
    │   ├── Cargo.toml
    │   ├── Makefile
    │   ├── rust-toolchain.toml
    │   ├── example-contract/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── sample-policy/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       └── lib.rs
    │   ├── smart-wallet/
    │   │   ├── Cargo.toml
    │   │   └── src/
    │   │       ├── base64_url.rs
    │   │       ├── context.rs
    │   │       ├── lib.rs
    │   │       ├── signer.rs
    │   │       ├── storage.rs
    │   │       ├── types.rs
    │   │       ├── verify.rs
    │   │       └── tests/
    │   │           ├── test.rs
    │   │           └── test_extra.rs
    │   └── smart-wallet-interface/
    │       ├── Cargo.toml
    │       └── src/
    │           ├── lib.rs
    │           └── types.rs
    ├── demo/
    │   ├── README.md
    │   ├── index.html
    │   ├── package.json
    │   ├── pnpm-lock.yaml
    │   ├── pnpm-workspace.yaml
    │   ├── svelte.config.js
    │   ├── tsconfig.json
    │   ├── tsconfig.node.json
    │   ├── vite.config.ts
    │   ├── .env.example
    │   └── src/
    │       ├── app.css
    │       ├── App.svelte
    │       ├── main.ts
    │       ├── vite-env.d.ts
    │       └── lib/
    │           └── common.ts
    ├── packages/
    │   ├── passkey-kit-sdk/
    │   │   ├── README.md
    │   │   ├── package.json
    │   │   ├── tsconfig.json
    │   │   ├── .npmignore
    │   │   └── src/
    │   │       └── index.ts
    │   └── sac-sdk/
    │       ├── README.md
    │       ├── package.json
    │       ├── tsconfig.json
    │       ├── .npmignore
    │       └── src/
    │           └── index.ts
    ├── src/
    │   ├── base.ts
    │   ├── index.ts
    │   ├── kit.ts
    │   ├── sac.ts
    │   ├── server.ts
    │   └── types.ts
    ├── zephyr/
    │   ├── Cargo.toml
    │   ├── rust-toolchain.toml
    │   ├── zephyr.toml
    │   ├── src/
    │   │   ├── lib.rs
    │   │   └── types.rs
    │   └── .cargo/
    │       └── config.toml
    └── .github/
        └── workflows/
            └── release.yml

================================================
FILE: README.md
================================================
# Passkey Kit

> [!WARNING]  
> Code in this repo is demo material only. It has not been audited. Do not use to hold, protect, or secure anything.

Passkey kit is a basic TypeScript SDK for creating and managing Stellar smart wallets. It's intended to be used in tandem with [Launchtube](https://github.com/stellar/launchtube) for submitting passkey signed transactions onchain however this is not a requirement. This is both a client and a server side library. `PasskeyKit` on the client and `PasskeyServer` on the server.

Demo site: [passkey-kit-demo.pages.dev](https://passkey-kit-demo.pages.dev/)

To get started first install the package:
```
pnpm i passkey-kit
```

On the client:
```ts
const account = new PasskeyKit({
    rpcUrl: env.PUBLIC_rpcUrl,
    networkPassphrase: env.PUBLIC_networkPassphrase,
    factoryContractId: env.PUBLIC_factoryContractId,
});
```

On the server:
```ts
const account = new PasskeyServer({
    rpcUrl: env.PUBLIC_rpcUrl,
    launchtubeUrl: env.PUBLIC_launchtubeUrl,
    launchtubeJwt: env.PRIVATE_launchtubeJwt,
    mercuryUrl: env.PUBLIC_mercuryUrl,
    mercuryJwt: env.PRIVATE_mercuryJwt,
});
```

This is a fully typed library so docs aren't provided, however there's a full example showcasing all the core public methods in the `./demo` directory. I also recommend reviewing the [Super Peach](https://github.com/kalepail/superpeach) repo for an example of how you could implement both the client and server side in a more real-world scenario.

Good luck, have fun, and change the world!

For any questions or to showcase your progress please join the `#passkeys` channel on our [Discord](https://discord.gg/stellardev).

## Deploy the event indexer

In order to utilize the Mercury Zephyr indexing service to track available signers and reverse lookup smart wallet contract addresses from passkey ids you'll need to deploy the Zephyr program from inside the `./zephyr` directory.

```bash
cd ./zephyr
cargo install mercury-cli
# Get a JWT from Mercury https://test.mercurydata.app
export MERCURY_JWT="<YOUR.MERCURY.JWT>"
# Make sure you're on Rust version 1.79.0 or newer
mercury-cli --jwt $MERCURY_JWT --local false --mainnet false deploy
```

## TypeScript gotchas

This is a TypeScript library and the npm package doesn't export a JavaScript version. The `@stellar/stellar-sdk` library is enormous and I really don't wan't folks bundling it up twice. Therefore you'll need to ensure you're transpiling this library into your project and that goes for either a TS project or a JS one. For many of you this will "just work" but for others you'll need to do some fiddling.

For example if you're using NextJS this will mean modifying your `next.config.mjs` file to include the following packages in the `transpilePackages` key:
```mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
    transpilePackages: [
        'passkey-kit', 
        'passkey-factory-sdk', 
        'passkey-kit-sdk',
        'sac-sdk',
    ]
};

export default nextConfig;
```
If someone smarter than me knows how to include an optional JS build from a TS library please submit a PR. I just don't want to deploy a compiled version of this and wind up having folks doubling up on an already gargantuan dependency.

## Contributing 

Passkey kit consists of three primary directories:
- `./src` - Contains the TypeScript files for the actual TS SDK library.
- `./demo` - Contains a basic demo of the SDK in action.
- `./contracts` - Contains the Rust Soroban smart contracts of the smart wallet implementation.
- `./zephyr` - Contains the [Zephyr](https://www.mercurydata.app/products/zephyr-vm) program for processing smart wallet events.

To install dependencies:

```bash
pnpm i
```

To build:

```bash
pnpm run build
```

To run the demo:

```bash
cd ./demo
pnpm i
pnpm run start
```

> [!IMPORTANT]
> If you fiddle with contracts in `./contracts` you'll need to run the make commands. Just remember to update the `SMART_WALLET_FACTORY` and `SMART_WALLET_WASM` values from the `make deploy` command before running `make init`.

> [!IMPORTANT]
> Keep in mind the bindings here in `./packages` have been _heavily_ modified. Be careful when rebuilding and updating. Likely you'll only want to update the `src/index.ts` files in each respective package vs swapping out entire directories.



================================================
FILE: cheatsheet.txt
================================================
# Install contract sdks
npm publish --workspaces

# Install passkey-kit
pnpm publish --no-git-checks

# Stellar commands
stellar contract bindings rust --wasm target/wasm32-unknown-unknown/release/smart_wallet.wasm
stellar contract deploy --wasm target/wasm32-unknown-unknown/release/sample_policy.wasm --network testnet --source default

# Mercury commands
# https://test.mercurydata.app/

export JWT=???
mercury-cli --jwt $JWT --local false --mainnet false deploy
mercury-cli --jwt $JWT --local false --mainnet false catchup --project-name "smart-wallets-next-dima" --contracts CBFOIYCWRC5LXYMF7VPM4MTBEIIMDJ6TBWYH2PY5U7MW73MINQNN3V7E
curl -X GET https://api.mercurydata.app/catchups/4
curl -X POST https://api.mercurydata.app/v2/key -H "Authorization: Bearer $JWT"


================================================
FILE: clone-js-sdk.sh
================================================
#!/bin/bash

cd ext/js-stellar-sdk/ 
yarn run clean
yarn run build:ts
yarn run build:node
yarn run build:browser
cd ../../

rm -rf ext/@stellar
mkdir -p ext/@stellar/stellar-sdk
cp -R ext/js-stellar-sdk/lib ext/@stellar/stellar-sdk/
cp -R ext/js-stellar-sdk/dist ext/@stellar/stellar-sdk/
cp -R ext/js-stellar-sdk/types ext/@stellar/stellar-sdk/ 
cp ext/js-stellar-sdk/package.json ext/@stellar/stellar-sdk/

cd demo/
rm -rf node_modules pnpm-lock.yaml
pnpm install

cd ../


================================================
FILE: LICENCE
================================================
MIT License

Copyright (c) 2024 Tyler van der Hoeven

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: package.json
================================================
{
  "name": "passkey-kit",
  "version": "0.10.24",
  "description": "A helper library for creating and using smart wallet accounts on the Stellar blockchain.",
  "author": "Tyler van der Hoeven",
  "license": "MIT",
  "type": "module",
  "main": "src/index.ts",
  "types": "types/index.d.ts",
  "scripts": {
    "build:demo": "cd demo && pnpm --ignore-workspace install && pnpm run build",
    "deploy:demo": "npx wrangler pages deploy",
    "deploy:demo:prod": "npx wrangler pages deploy --env production",
    "prepublishOnly": "pnpm run build",
    "build:sac": "pnpm --filter=sac-sdk run build",
    "build:pks": "pnpm --filter=passkey-kit-sdk run build",
    "build": "pnpm run build:sac && pnpm run build:pks && tsc",
    "ext:cp": "./clone-js-sdk.sh"
  },
  "dependencies": {
    "@simplewebauthn/browser": "^13.1.0",
    "@stellar/stellar-sdk": "^13.3.0",
    "base64url": "^3.0.1",
    "buffer": "^6.0.3",
    "passkey-kit-sdk": "workspace:*",
    "sac-sdk": "workspace:*"
  },
  "devDependencies": {
    "@simplewebauthn/types": "^12.0.0",
    "@types/node": "^22.15.3",
    "typescript": "^5.8.3"
  },
  "pnpm": {
    "overrides": {
      "@stellar/stellar-sdk": "$@stellar/stellar-sdk"
    }
  },
  "workspaces": [
    "packages/*"
  ],
  "engine": {
    "node": ">=20"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kalepail/passkey-kit.git"
  },
  "keywords": [
    "smart wallet",
    "passkey",
    "webauthn",
    "blockchain",
    "stellar",
    "web3",
    "account abstraction",
    "secp256r1",
    "ed25519",
    "policy signer",
    "crypto"
  ],
  "bugs": {
    "url": "https://github.com/kalepail/passkey-kit/issues"
  },
  "homepage": "https://github.com/kalepail/passkey-kit/blob/main/README.md"
}



================================================
FILE: pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

overrides:
  '@stellar/stellar-sdk': ^13.3.0

importers:

  .:
    dependencies:
      '@simplewebauthn/browser':
        specifier: ^13.1.0
        version: 13.1.0
      '@stellar/stellar-sdk':
        specifier: ^13.3.0
        version: 13.3.0
      base64url:
        specifier: ^3.0.1
        version: 3.0.1
      buffer:
        specifier: ^6.0.3
        version: 6.0.3
      passkey-kit-sdk:
        specifier: workspace:*
        version: link:packages/passkey-kit-sdk
      sac-sdk:
        specifier: workspace:*
        version: link:packages/sac-sdk
    devDependencies:
      '@simplewebauthn/types':
        specifier: ^12.0.0
        version: 12.0.0
      '@types/node':
        specifier: ^22.15.3
        version: 22.15.3
      typescript:
        specifier: ^5.8.3
        version: 5.8.3

  packages/passkey-kit-sdk:
    dependencies:
      '@stellar/stellar-sdk':
        specifier: ^13.3.0
        version: 13.3.0
      buffer:
        specifier: ^6.0.3
        version: 6.0.3
    devDependencies:
      typescript:
        specifier: ^5.8.3
        version: 5.8.3

  packages/sac-sdk:
    dependencies:
      '@stellar/stellar-sdk':
        specifier: ^13.3.0
        version: 13.3.0
      buffer:
        specifier: ^6.0.3
        version: 6.0.3
    devDependencies:
      typescript:
        specifier: ^5.8.3
        version: 5.8.3

packages:

  '@simplewebauthn/browser@13.1.0':
    resolution: {integrity: sha512-WuHZ/PYvyPJ9nxSzgHtOEjogBhwJfC8xzYkPC+rR/+8chl/ft4ngjiK8kSU5HtRJfczupyOh33b25TjYbvwAcg==}

  '@simplewebauthn/types@12.0.0':
    resolution: {integrity: sha512-q6y8MkoV8V8jB4zzp18Uyj2I7oFp2/ONL8c3j8uT06AOWu3cIChc1au71QYHrP2b+xDapkGTiv+9lX7xkTlAsA==}

  '@stellar/js-xdr@3.1.2':
    resolution: {integrity: sha512-VVolPL5goVEIsvuGqDc5uiKxV03lzfWdvYg1KikvwheDmTBO68CKDji3bAZ/kppZrx5iTA8z3Ld5yuytcvhvOQ==}

  '@stellar/stellar-base@13.1.0':
    resolution: {integrity: sha512-90EArG+eCCEzDGj3OJNoCtwpWDwxjv+rs/RNPhvg4bulpjN/CSRj+Ys/SalRcfM4/WRC5/qAfjzmJBAuquWhkA==}
    engines: {node: '>=18.0.0'}

  '@stellar/stellar-sdk@13.3.0':
    resolution: {integrity: sha512-8+GHcZLp+mdin8gSjcgfb/Lb6sSMYRX6Nf/0LcSJxvjLQR0XHpjGzOiRbYb2jSXo51EnA6kAV5j+4Pzh5OUKUg==}
    engines: {node: '>=18.0.0'}

  '@types/node@22.15.3':
    resolution: {integrity: sha512-lX7HFZeHf4QG/J7tBZqrCAXwz9J5RD56Y6MpP0eJkka8p+K0RY/yBTW7CYFJ4VGCclxqOLKmiGP5juQc6MKgcw==}

  asynckit@0.4.0:
    resolution: {integrity: sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==}

  axios@1.9.0:
    resolution: {integrity: sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==}

  bare-addon-resolve@1.9.4:
    resolution: {integrity: sha512-unn6Vy/Yke6F99vg/7tcrvM2KUvIhTNniaSqDbam4AWkd4NhvDVSrQiRYVlNzUV2P7SPobkCK7JFVxrJk9btCg==}
    peerDependencies:
      bare-url: '*'
    peerDependenciesMeta:
      bare-url:
        optional: true

  bare-module-resolve@1.10.2:
    resolution: {integrity: sha512-C9COe/GhWfVXKytW3DElTkiBU+Gb2OXeaVkdGdRB/lp26TVLESHkTGS876iceAGdvtPgohfp9nX8vXHGvN3++Q==}
    peerDependencies:
      bare-url: '*'
    peerDependenciesMeta:
      bare-url:
        optional: true

  bare-os@3.6.1:
    resolution: {integrity: sha512-uaIjxokhFidJP+bmmvKSgiMzj2sV5GPHaZVAIktcxcpCyBFFWO+YlikVAdhmUo2vYFvFhOXIAlldqV29L8126g==}
    engines: {bare: '>=1.14.0'}

  bare-path@3.0.0:
    resolution: {integrity: sha512-tyfW2cQcB5NN8Saijrhqn0Zh7AnFNsnczRcuWODH0eYAXBsJ5gVxAUuNr7tsHSC6IZ77cA0SitzT+s47kot8Mw==}

  bare-semver@1.0.1:
    resolution: {integrity: sha512-UtggzHLiTrmFOC/ogQ+Hy7VfoKoIwrP1UFcYtTxoCUdLtsIErT8+SWtOC2DH/snT9h+xDrcBEPcwKei1mzemgg==}

  bare-url@2.1.6:
    resolution: {integrity: sha512-FgjDeR+/yDH34By4I0qB5NxAoWv7dOTYcOXwn73kr+c93HyC2lU6tnjifqUe33LKMJcDyCYPQjEAqgOQiXkE2Q==}

  base32.js@0.1.0:
    resolution: {integrity: sha512-n3TkB02ixgBOhTvANakDb4xaMXnYUVkNoRFJjQflcqMQhyEKxEHdj3E6N8t8sUQ0mjH/3/JxzlXuz3ul/J90pQ==}
    engines: {node: '>=0.12.0'}

  base64-js@1.5.1:
    resolution: {integrity: sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==}

  base64url@3.0.1:
    resolution: {integrity: sha512-ir1UPr3dkwexU7FdV8qBBbNDRUhMmIekYMFZfi+C/sLNnRESKPl23nB9b2pltqfOQNnGzsDdId90AEtG5tCx4A==}
    engines: {node: '>=6.0.0'}

  bignumber.js@9.3.0:
    resolution: {integrity: sha512-EM7aMFTXbptt/wZdMlBv2t8IViwQL+h6SLHosp8Yf0dqJMTnY6iL32opnAB6kAdL0SZPuvcAzFr31o0c/R3/RA==}

  buffer@6.0.3:
    resolution: {integrity: sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==}

  call-bind-apply-helpers@1.0.2:
    resolution: {integrity: sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==}
    engines: {node: '>= 0.4'}

  combined-stream@1.0.8:
    resolution: {integrity: sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==}
    engines: {node: '>= 0.8'}

  delayed-stream@1.0.0:
    resolution: {integrity: sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==}
    engines: {node: '>=0.4.0'}

  dunder-proto@1.0.1:
    resolution: {integrity: sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==}
    engines: {node: '>= 0.4'}

  es-define-property@1.0.1:
    resolution: {integrity: sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==}
    engines: {node: '>= 0.4'}

  es-errors@1.3.0:
    resolution: {integrity: sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==}
    engines: {node: '>= 0.4'}

  es-object-atoms@1.1.1:
    resolution: {integrity: sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==}
    engines: {node: '>= 0.4'}

  es-set-tostringtag@2.1.0:
    resolution: {integrity: sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==}
    engines: {node: '>= 0.4'}

  eventsource@2.0.2:
    resolution: {integrity: sha512-IzUmBGPR3+oUG9dUeXynyNmf91/3zUSJg1lCktzKw47OXuhco54U3r9B7O4XX+Rb1Itm9OZ2b0RkTs10bICOxA==}
    engines: {node: '>=12.0.0'}

  feaxios@0.0.23:
    resolution: {integrity: sha512-eghR0A21fvbkcQBgZuMfQhrXxJzC0GNUGC9fXhBge33D+mFDTwl0aJ35zoQQn575BhyjQitRc5N4f+L4cP708g==}

  follow-redirects@1.15.9:
    resolution: {integrity: sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ==}
    engines: {node: '>=4.0'}
    peerDependencies:
      debug: '*'
    peerDependenciesMeta:
      debug:
        optional: true

  form-data@4.0.2:
    resolution: {integrity: sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==}
    engines: {node: '>= 6'}

  function-bind@1.1.2:
    resolution: {integrity: sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==}

  get-intrinsic@1.3.0:
    resolution: {integrity: sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==}
    engines: {node: '>= 0.4'}

  get-proto@1.0.1:
    resolution: {integrity: sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==}
    engines: {node: '>= 0.4'}

  gopd@1.2.0:
    resolution: {integrity: sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==}
    engines: {node: '>= 0.4'}

  has-symbols@1.1.0:
    resolution: {integrity: sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==}
    engines: {node: '>= 0.4'}

  has-tostringtag@1.0.2:
    resolution: {integrity: sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==}
    engines: {node: '>= 0.4'}

  hasown@2.0.2:
    resolution: {integrity: sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==}
    engines: {node: '>= 0.4'}

  ieee754@1.2.1:
    resolution: {integrity: sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==}

  inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}

  is-retry-allowed@3.0.0:
    resolution: {integrity: sha512-9xH0xvoggby+u0uGF7cZXdrutWiBiaFG8ZT4YFPXL8NzkyAwX3AKGLeFQLvzDpM430+nDFBZ1LHkie/8ocL06A==}
    engines: {node: '>=12'}

  math-intrinsics@1.1.0:
    resolution: {integrity: sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==}
    engines: {node: '>= 0.4'}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  proxy-from-env@1.1.0:
    resolution: {integrity: sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==}

  randombytes@2.1.0:
    resolution: {integrity: sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==}

  require-addon@1.1.0:
    resolution: {integrity: sha512-KbXAD5q2+v1GJnkzd8zzbOxchTkStSyJZ9QwoCq3QwEXAaIlG3wDYRZGzVD357jmwaGY7hr5VaoEAL0BkF0Kvg==}
    engines: {bare: '>=1.10.0'}

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  sha.js@2.4.11:
    resolution: {integrity: sha512-QMEp5B7cftE7APOjk5Y6xgrbWu+WkLVQwk8JNjZ8nKRciZaByEW6MubieAiToS7+dwvrjGhH8jRXz3MVd0AYqQ==}
    hasBin: true

  sodium-native@4.3.3:
    resolution: {integrity: sha512-OnxSlN3uyY8D0EsLHpmm2HOFmKddQVvEMmsakCrXUzSd8kjjbzL413t4ZNF3n0UxSwNgwTyUvkmZHTfuCeiYSw==}

  toml@3.0.0:
    resolution: {integrity: sha512-y/mWCZinnvxjTKYhJ+pYxwD0mRLVvOtdS2Awbgxln6iEnt4rk0yBxeSBHkGJcPucRiG0e55mwWp+g/05rsrd6w==}

  tweetnacl@1.0.3:
    resolution: {integrity: sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==}

  typescript@5.8.3:
    resolution: {integrity: sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  undici-types@6.21.0:
    resolution: {integrity: sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==}

  urijs@1.19.11:
    resolution: {integrity: sha512-HXgFDgDommxn5/bIv0cnQZsPhHDA90NPHD6+c/v21U5+Sx5hoP8+dP9IZXBU1gIfvdRfhG8cel9QNPeionfcCQ==}

snapshots:

  '@simplewebauthn/browser@13.1.0': {}

  '@simplewebauthn/types@12.0.0': {}

  '@stellar/js-xdr@3.1.2': {}

  '@stellar/stellar-base@13.1.0':
    dependencies:
      '@stellar/js-xdr': 3.1.2
      base32.js: 0.1.0
      bignumber.js: 9.3.0
      buffer: 6.0.3
      sha.js: 2.4.11
      tweetnacl: 1.0.3
    optionalDependencies:
      sodium-native: 4.3.3

  '@stellar/stellar-sdk@13.3.0':
    dependencies:
      '@stellar/stellar-base': 13.1.0
      axios: 1.9.0
      bignumber.js: 9.3.0
      eventsource: 2.0.2
      feaxios: 0.0.23
      randombytes: 2.1.0
      toml: 3.0.0
      urijs: 1.19.11
    transitivePeerDependencies:
      - debug

  '@types/node@22.15.3':
    dependencies:
      undici-types: 6.21.0

  asynckit@0.4.0: {}

  axios@1.9.0:
    dependencies:
      follow-redirects: 1.15.9
      form-data: 4.0.2
      proxy-from-env: 1.1.0
    transitivePeerDependencies:
      - debug

  bare-addon-resolve@1.9.4(bare-url@2.1.6):
    dependencies:
      bare-module-resolve: 1.10.2(bare-url@2.1.6)
      bare-semver: 1.0.1
    optionalDependencies:
      bare-url: 2.1.6
    optional: true

  bare-module-resolve@1.10.2(bare-url@2.1.6):
    dependencies:
      bare-semver: 1.0.1
    optionalDependencies:
      bare-url: 2.1.6
    optional: true

  bare-os@3.6.1:
    optional: true

  bare-path@3.0.0:
    dependencies:
      bare-os: 3.6.1
    optional: true

  bare-semver@1.0.1:
    optional: true

  bare-url@2.1.6:
    dependencies:
      bare-path: 3.0.0
    optional: true

  base32.js@0.1.0: {}

  base64-js@1.5.1: {}

  base64url@3.0.1: {}

  bignumber.js@9.3.0: {}

  buffer@6.0.3:
    dependencies:
      base64-js: 1.5.1
      ieee754: 1.2.1

  call-bind-apply-helpers@1.0.2:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2

  combined-stream@1.0.8:
    dependencies:
      delayed-stream: 1.0.0

  delayed-stream@1.0.0: {}

  dunder-proto@1.0.1:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-errors: 1.3.0
      gopd: 1.2.0

  es-define-property@1.0.1: {}

  es-errors@1.3.0: {}

  es-object-atoms@1.1.1:
    dependencies:
      es-errors: 1.3.0

  es-set-tostringtag@2.1.0:
    dependencies:
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  eventsource@2.0.2: {}

  feaxios@0.0.23:
    dependencies:
      is-retry-allowed: 3.0.0

  follow-redirects@1.15.9: {}

  form-data@4.0.2:
    dependencies:
      asynckit: 0.4.0
      combined-stream: 1.0.8
      es-set-tostringtag: 2.1.0
      mime-types: 2.1.35

  function-bind@1.1.2: {}

  get-intrinsic@1.3.0:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      function-bind: 1.1.2
      get-proto: 1.0.1
      gopd: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      math-intrinsics: 1.1.0

  get-proto@1.0.1:
    dependencies:
      dunder-proto: 1.0.1
      es-object-atoms: 1.1.1

  gopd@1.2.0: {}

  has-symbols@1.1.0: {}

  has-tostringtag@1.0.2:
    dependencies:
      has-symbols: 1.1.0

  hasown@2.0.2:
    dependencies:
      function-bind: 1.1.2

  ieee754@1.2.1: {}

  inherits@2.0.4: {}

  is-retry-allowed@3.0.0: {}

  math-intrinsics@1.1.0: {}

  mime-db@1.52.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  proxy-from-env@1.1.0: {}

  randombytes@2.1.0:
    dependencies:
      safe-buffer: 5.2.1

  require-addon@1.1.0:
    dependencies:
      bare-addon-resolve: 1.9.4(bare-url@2.1.6)
      bare-url: 2.1.6
    optional: true

  safe-buffer@5.2.1: {}

  sha.js@2.4.11:
    dependencies:
      inherits: 2.0.4
      safe-buffer: 5.2.1

  sodium-native@4.3.3:
    dependencies:
      require-addon: 1.1.0
    optional: true

  toml@3.0.0: {}

  tweetnacl@1.0.3: {}

  typescript@5.8.3: {}

  undici-types@6.21.0: {}

  urijs@1.19.11: {}



================================================
FILE: pnpm-workspace.yaml
================================================
packages:
  - 'packages/**'


================================================
FILE: PROPOSAL.md
================================================
# Smart wallet contract interface

With the release of [Protocol 21](https://stellar.org/blog/developers/announcing-protocol-21) (and specifically the inclusion of the secp256r1 verification  curve) Soroban now has tremendous first class support for passkey powered smart wallets.

Over the past months I've been hard at work designing a solid first stab at a v1 smart wallet contract interface for mainnet use. This is the culmination of that work in proposal form.

All the best work can reviewed in my [passkey-kit](https://github.com/kalepail/passkey-kit) repo. This repo includes the factory and wallet contracts, a demo client interface, a `passkey-kit` SDK tool to make interacting with the contract interface simple and painless and finally a [Mercury Zephyr](https://www.mercurydata.app/products/zephyr-vm) program for indexing contract events in order to make the wallet more usable client side.

This repo also makes use of a new [Launchtube service](https://github.com/kalepail/launchtube) which makes submitting Soroban transactions simple by handling the concerns of both transaction fees and sequence numbers.

The primary interest of this proposal is to detail the contract interface itself but many of the design decisions are informed by complexities and available solutions external to the interface. A well rounded understandings of all that's involved to make passkey powered smart wallets on Stellar actually work is necessary in order to arrive at a truly viable contract interface.

This proposal consists of two contracts, a factory “deployer” contract and the actual smart wallet interface.

# Contract 1: The Factory

Stellar doesn’t allow us to both deploy and initialize a contract atomically and so the ecosystem has adopted the workaround of having a factory contract which handles the deploying and then calling of the newly deployed contract’s initialize function. This deploy and init can happen atomically within Soroban.

The side benefit is we can ensure consistency of all contracts deployed from the same factory address. As long as the contract was deployed from a known factory address users and services have a guarantee of the initial inner form of the smart wallet. As we’ll see smart wallets have an `upgrade` method which will effectively break this guarantee but at the end of the day it’s a contract’s WASM hash we actually care about vs it’s factory address.

## Interface

```rust
// FUNCTIONS

fn init(wasm_hash: bytesn<32>) -> result<tuple<>,error>

fn deploy(id: bytes, pk: bytesn<65>) -> result<address,error>

// ERRORS

#[contracterror]
enum Error {
    NotInitialized = 1,
    AlreadyInitialized = 2
}
```

## Code

[https://github.com/kalepail/passkey-kit/blob/main/contracts/smart-wallet-factory/src/lib.rs](https://github.com/kalepail/passkey-kit/blob/main/contracts/smart-wallet-factory/src/lib.rs)

 

```rust
const WEEK_OF_LEDGERS: u32 = 60 * 60 * 24 / 5 * 7;
const STORAGE_KEY_WASM_HASH: Symbol = symbol_short!("hash");
```

Only thing to note in this block is I’m opting to max extend this contract’s instance during every call with a threshold of 7 days. This will be the same for the wallet interface itself. This will cause the initial calls for any storage write function to be somewhat inflated with the beneficial tradeoff that folks won’t have to worry about their wallets or keys expiring or archiving for `max_ttl` time. In my tests this cost was minimal and the improved UX of not having to worry about restoring archived entries in my opinion was worth it.

We could decide to make these values instance variables which could be updated or even make them configurable on a key by key basis however that would increase complexity and cost in many cases and without further real world data to support that choice I’m suggesting simplicity.

### `init`
```rust
pub fn init(env: Env, wasm_hash: BytesN<32>) -> Result<(), Error> {
    if env.storage().instance().has(&STORAGE_KEY_WASM_HASH) {
        return Err(Error::AlreadyInitialized);
    }

    let max_ttl = env.storage().max_ttl();

    env.storage()
        .instance()
        .set(&STORAGE_KEY_WASM_HASH, &wasm_hash);

    env.storage()
        .instance()
        .extend_ttl(max_ttl - WEEK_OF_LEDGERS, max_ttl);

    Ok(())
}
```

Nothing controversial here I don’t think. We’re storing the smart wallet’s wasm hash in order to load up the factory with the proper template to deploy in the `deploy` function. This is stored on the instance as it should be and then the instance is extended 

### `deploy`
```rust
pub fn deploy(env: Env, salt: BytesN<32>, id: Bytes, pk: BytesN<65>) -> Result<Address, Error> {
    let wasm_hash = env
        .storage()
        .instance()
        .get::<Symbol, BytesN<32>>(&STORAGE_KEY_WASM_HASH)
        .ok_or(Error::NotInitialized)?;

    let address = env
        .deployer()
        .with_current_contract(salt)
        .deploy(wasm_hash);

    let () = env.invoke_contract(
        &address,
        &symbol_short!("add"),
        vec![&env, id.to_val(), pk.to_val(), true.into()],
    );

    let max_ttl = env.storage().max_ttl();

    env.storage()
        .instance()
        .extend_ttl(max_ttl - WEEK_OF_LEDGERS, max_ttl);

    Ok(address)
}
```

Few things to note here:

- Also note we’re calling the `env.invoke_contract` vs pulling in the smart wallet interface. This is a cost savings as we’re only making use of the `add` method. This requires knowing intuitively how to properly construct the invocation but let’s be honest, that’s not hard.
- Last thing is extending the interface again. If you’re gonna use the factory at least pay it forward a little to help keep the factory’s lights on.

# Contract 2: The Smart Wallet

The smart wallet interface while obviously more complex than the factory is still aiming to be as simple as possible and only do what’s absolutely necessary to provide a useful smart wallet interface for general purpose usage.

I’ve intentionally left off as many bells and whistles as possible with the hope of being able to agree and progress with this interface into an audited and approved mainnet interface for general usage. Certainly there will be additional features and functions users and services will want and I hope to see a rich and diverse ecosystem of wallet interfaces arise over time but initially we just need to get something sufficiently useful live providing the basic majority needs of non crypto-native users.

## Interface

```rust
// FUNCTIONS

fn add(id: bytes, pk: bytesn<65>, admin: bool) -> result<tuple<>,error>

fn remove(id: bytes) -> result<tuple<>,error>

fn upgrade(hash: bytesn<32>) -> result<tuple<>,error>

fn __check_auth(signature_payload: bytesn<32>, signature: Signature, auth_contexts: vec<Context>) -> result<tuple<>,error>

// STRUCTS

#[contracttype]
struct Signature {
    authenticator_data: bytes,
    client_data_json: bytes,
    id: bytes,
    signature: bytesn<64>
}

// ERRORS

#[contracterror]
enum Error {
    NotFound = 1,
    NotPermitted = 2,
    ClientDataJsonChallengeIncorrect = 3,
    Secp256r1PublicKeyParse = 4,
    Secp256r1SignatureParse = 5,
    Secp256r1VerifyFailed = 6,
    JsonParseError = 7,
}

```

## Code

[https://github.com/kalepail/passkey-kit/blob/main/contracts/smart-wallet/src/lib.rs](https://github.com/kalepail/passkey-kit/blob/main/contracts/smart-wallet/src/lib.rs)

### `add`
```rust
pub fn add(env: Env, id: Bytes, pk: BytesN<65>, mut admin: bool) -> Result<(), Error> {
    if env.storage().instance().has(&ADMIN_SIGNER_COUNT) {
        env.current_contract_address().require_auth();   
    } else {
        admin = true;
    }

    let max_ttl = env.storage().max_ttl();

    if admin {
        if env.storage().temporary().has(&id) {
            env.storage().temporary().remove(&id);
        }

        Self::update_admin_signer_count(&env, true);

        env.storage().persistent().set(&id, &pk);

        env.storage()
            .persistent()
            .extend_ttl(&id, max_ttl - WEEK_OF_LEDGERS, max_ttl);
    } else {
        if env.storage().persistent().has(&id) {
            Self::update_admin_signer_count(&env, false);

            env.storage().persistent().remove(&id);
        }

        env.storage().temporary().set(&id, &pk);

        env.storage()
            .temporary()
            .extend_ttl(&id, max_ttl - WEEK_OF_LEDGERS, max_ttl);
    }

    env.storage()
        .instance()
        .extend_ttl(max_ttl - WEEK_OF_LEDGERS, max_ttl);

    env.events()
        .publish((EVENT_TAG, symbol_short!("add"), id), (pk, admin));

    Ok(())
}
```

Some notable elements:

- We use the `env.storage().instance().has(&ADMIN_SIGNER_COUNT)` to toggle between a sort of initialization call and the standard `require_auth` flow.
    
    ```rust
    if env.storage().instance().has(&ADMIN_SIGNER_COUNT) {
        env.current_contract_address().require_auth();   
    } else {
        admin = true;
    }
    ```
    
    The only potential downside is `add` includes logic for storing temporary session signers which an initial call doesn't support making that logic verbose. Initially I had a separate `init` function but I think this is a better tradeoff for simplicity and efficiency even if there are some unusable if statements in the case of the initial `add` call made by the factory contract.
    
- `Self::update_admin_signer_count(&env, true);` My proposal includes the concept of session and admin signers. Certain functions, well really all of the smart wallet self functions (`add`, `remove`, `upgrade`) are only callable by admin signers. Given this we need to ensure we never remove all the admin signers which necessarily requires we track the number of admin signers. This function provides that service and will be called anytime we add or remove an admin signer.
- Admin signers are persistent entries, non-admin signers are temporary. It’s also possible for signers to be toggled between admin and non however we must only ever be tracking a single `id` to a single `pk` and so we must add logic for removing any existing signers for a given `id` in the counter storage to the type we’re currently adding to. Make special note of the need to decrement the `ADMIN_SIGNER_COUNT` in case of removing an admin signer to temporary if a persistent entry for that `id` exists.
    
    ```rust
    if admin {
        if env.storage().temporary().has(&id) {
            env.storage().temporary().remove(&id);
        }
    
        Self::update_admin_signer_count(&env, true);
    
        env.storage().persistent().set(&id, &pk);
    
        env.storage()
            .persistent()
            .extend_ttl(&id, max_ttl - WEEK_OF_LEDGERS, max_ttl);
    } else {
        if env.storage().persistent().has(&id) {
            Self::update_admin_signer_count(&env, false);
    
            env.storage().persistent().remove(&id);
        }
    
        env.storage().temporary().set(&id, &pk);
    
        env.storage()
            .temporary()
            .extend_ttl(&id, max_ttl - WEEK_OF_LEDGERS, max_ttl);
    }
    ```
    
### `remove`
```rust
pub fn remove(env: Env, id: Bytes) -> Result<(), Error> {
    env.current_contract_address().require_auth();

    if env.storage().temporary().has(&id) {
        env.storage().temporary().remove(&id);
    } else {
        Self::update_admin_signer_count(&env, false);

        env.storage().persistent().remove(&id);
    }

    let max_ttl = env.storage().max_ttl();

    env.storage()
        .instance()
        .extend_ttl(max_ttl - WEEK_OF_LEDGERS, max_ttl);

    env.events()
        .publish((EVENT_TAG, symbol_short!("remove"), id), ());

    Ok(())
}
```

Remove is similar to `add` just in inverse with some slight simplifications.

- Given the key could be either temporary or persistent we must include logic for checking both and removing if they exist. Again note the need to decrement the `ADMIN_SIGNER_COUNT` in case of a persistent admin `id`.
- Given each `id` can only be either a temporary or persistent entry it's safe to use `else if env.storage().persistent().has(&id)` vs a separate `if ...`. Doing so saves on some read costs if we were to try and just remove both storage type for the same `id` key. Note we do need to use the has check vs just doing an `else` check as a `storage.remove` won't error if the entry doesn't exist which would open us up to the issue of decrementing the admin key count when we didn't actually delete anything.

### `update`
```rust
pub fn update(env: Env, hash: BytesN<32>) -> Result<(), Error> {
    env.current_contract_address().require_auth();

    env.deployer().update_current_contract_wasm(hash);

    let max_ttl = env.storage().max_ttl();

    env.storage()
        .instance()
        .extend_ttl(max_ttl - WEEK_OF_LEDGERS, max_ttl);

    Ok(())
}
```

An essential function for all smart wallets imo. The ability to change the interface the wallet implements. Perhaps controversial given the risk of upgrading to a bugged or malicious wallet interface but that’s an risk inherent to creating a smart wallet in the first place and given that risk I actually think part of mitigating that risk is allowing users to move their interface to alternatives should they choose to. Client interfaces should be very careful in exposing this method to wallet users but I do think it’s an essential method for the health and safety of the smart wallet ecosystem.

- Protected such that only admin signers can perform this method.
- Allows for a wallet user to switch or update their interface should newer or different interfaces be released.

### `__check_auth`
```rust
fn __check_auth(
    env: Env,
    signature_payload: Hash<32>,
    signature: Signature,
    auth_contexts: Vec<Context>,
) -> Result<(), Error> {...}
```

This is the beefy boy and most of it is only interesting to auditors ensuring the actual decoding and cryptography bits work as intended. I’ll detail the parts here which are more specific to the interface itself:

- We need to select which `pk` to use for the provided `id` purporting to have signed for the incoming payload.
    
    ```rust
    let pk = match env.storage().temporary().get(&id) {
      Some(pk) => {
          ...
    
          env.storage()
              .temporary()
              .extend_ttl(&id, max_ttl - WEEK_OF_LEDGERS, max_ttl);
    
          pk
      }
      None => {
          env.storage()
              .persistent()
              .extend_ttl(&id, max_ttl - WEEK_OF_LEDGERS, max_ttl);
    
          env.storage().persistent().get(&id).ok_or(Error::NotFound)?
      }
    };
    ```
    
    We do that first by looking up the temporary entry which will be the far more common case. If we cannot find it there we look for a persistent entry. This will introduce a double look up for a temporary entry but those are cheap so this is fine. Note we also set the `admin` binary toggle for use later in blocking protected self methods.
    
- If the pk is a temporary session signer we need to do an additional check to ensure the authentication request isn’t for a protected action
    
    ```rust
    
    ...
    
    for context in auth_contexts.iter() {
        match context {
            Context::Contract(c) => {
                if c.contract == env.current_contract_address()
                    && (
                        c.fn_name != symbol_short!("remove")
                        || (
                            c.fn_name == symbol_short!("remove") 
                            && Bytes::from_val(&env, &c.args.get(0).unwrap()) != id
                        )
                    )
                {
                    return Err(Error::NotPermitted);
                }
            }
            _ => {}
        };
    }
    
    ...
    ```
    
    This is a relatively straight forward check. If the request is for the smart wallet contract ensure the only function it *might* be able to call is a `remove` of it’s own `id`. Anything else should result in an error.
    

The rest of `__check_auth` is boilerplate authentication checks of the signature data itself and not technically part of this interface. It needs to be audited but that won’t affect the final interface of the wallet.

# Events

The only other item worth mentioning are the events emitted during the `add` and `remove` methods. Events are emitted in order to allow an indexer to keep track of a wallet’s available signers and their current state as `admin` or not.

## Add

```rust
env.events().publish((EVENT_TAG, symbol_short!("add"), id), (pk, admin));
```

- The `EVENT_TAG` is a trigger to help indexers only listen for relevant smart wallet events and while not fool proof should improve filtering out only those events which are relevant.
- The `pk` is emitted in order to allow downstream clients to queue up expired session signers to be re-added without needing to create new passkeys, you can continue to use the existing ones if you can find the `pk` for a matching `id` from a previously emitted event.
    
> [!CAUTION]
> Passkey public keys are only retrievable during a passkey creation flow. They cannot be later retrieved from an authentication flow. Thus passkey public keys are special data which we should be storing inside the blockchain itself. This is normally done during an `add` event but given we’re using temporary storage these keys could be lost and unrecoverable were we not to store them inside events for indexers to keep track of and then for clients to then be able to essentially “rehydrate” at a later date without requiring the user to keep creating new passkeys every time they wanted to sign into a service after their temporary session key had expired.
    

## Remove

```rust
env.events().publish((EVENT_TAG, symbol_short!("remove"), id), ());
```


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "outDir": "./types",
    "rootDir": "./src",
    // Enable latest features
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    // Bundler mode
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "declaration": true,
    "emitDeclarationOnly": true,
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
    "strictNullChecks": true,
  },
  "include": [
    "src",
  ],
}


================================================
FILE: .npmignore
================================================
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

meta.json

package

bun_tests/
contracts/
demo/
ext/
zephyr/

# TODO can we toss packages as well?
# Have more to toss here as well. Ideally this was allow list vs block list
# I think there's things we can do in the package.json to help with this. "exports", maybe, etc.


================================================
FILE: bun_tests/README.md
================================================
# tests

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.1.8. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.



================================================
FILE: bun_tests/0.index.ts
================================================
import { Account, nativeToScVal, Operation, StrKey, TransactionBuilder } from '@stellar/stellar-sdk';
import { Server } from '@stellar/stellar-sdk/rpc';

const networkPassphrase = 'Test SDF Network ; September 2015'
const rpcUrl = 'https://soroban-testnet.stellar.org'
const rpc = new Server(rpcUrl)

const mockPubkey = StrKey.encodeEd25519PublicKey(Buffer.alloc(32))
const mockSource = new Account(mockPubkey, '0')

const id = Buffer.from([125,176,117,115,57,12,172,162,174,94,93,239,223,251,112,31,79,213,168,149])
const pk = Buffer.from([4,145,97,10,184,102,167,68,139,113,167,62,97,52,78,114,175,146,41,171,173,84,128,243,131,159,105,166,51,123,134,42,245,34,106,52,208,45,27,210,224,216,175,242,131,119,135,110,65,212,130,170,215,213,20,100,121,31,108,140,154,13,115,198,184])

const transaction = new TransactionBuilder(mockSource, {
    fee: '0',
    networkPassphrase,
})
.addOperation(Operation.invokeContractFunction({
    contract: 'CCU4ZFRZXJO4YWOUJDO7PWCYN6YFTMBDYFJFQ6R7SEOLFU5PNJNZA46W',
    function: 'deploy',
    args: [
        nativeToScVal(id),
        nativeToScVal(pk),
    ]
}))
.setTimeout(0)
.build()

console.log(transaction.toXDR());

const sim = await rpc._simulateTransaction(transaction)

console.log(sim);

// if (!SorobanRpc.Api.isSimulationSuccess(sim)) {
//     throw sim
// }

// console.log(sim);



================================================
FILE: bun_tests/1.index.ts
================================================
import { xdr } from '@stellar/stellar-sdk';

const eventXDR = "AAAAAQAAAAAAAAABnUGtbB9pyBlyh+Q9MYjiiXLowBWO71Mz9WKbJ1z31ZgAAAABAAAAAAAAAAQAAAAPAAAABXN3X3YxAAAAAAAADwAAAANhZGQAAAAADQAAABR1uCpn7oY1jSi/pSfwW2e/YChYLgAAAA8AAAAEaW5pdAAAABAAAAABAAAAAgAAAA0AAABBBBs4FcABSsrQUBdm1u3Li1VPxppm2vqLR8EmaVdtlWI+WVvRnMesQxro9mTiF9Dn14HjKGlPjElWbR6beIsoVcYAAAAAAAAAAAAAAQ=="

const event = xdr.DiagnosticEvent.fromXDR(eventXDR, 'base64')

console.log(
    event.event().body().v0().data().toXDR().length
);



================================================
FILE: bun_tests/2.index.ts
================================================
import base64url from 'base64url'

let publicKey = base64url.toBuffer("MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEIWhAQyE5H-_9WM__87tYZq3yJPQ0rostof00z3MMSMqG3SuBh2TaTUHQDwd4CHyArPQ4EhKoScPbq0zxm1k_Dw")
let authenticatorData = base64url.toBuffer("SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NBAAAABAAAAAAAAAAAAAAAAAAAAAAAQA8EYfqizPJVk0HtwVdqazrXmAyb7tuHDD7PzBmf6gFOyCngKjd1RCTIQHCpS3SMyeYULBg7Ykx6n1usOd5PlSilAQIDJiABIVggIWhAQyE5H-_9WM__87tYZq3yJPQ0rostof00z3MMSMoiWCCG3SuBh2TaTUHQDwd4CHyArPQ4EhKoScPbq0zxm1k_Dw")
let attestationObject = base64url.toBuffer("o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjESZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2NBAAAABAAAAAAAAAAAAAAAAAAAAAAAQA8EYfqizPJVk0HtwVdqazrXmAyb7tuHDD7PzBmf6gFOyCngKjd1RCTIQHCpS3SMyeYULBg7Ykx6n1usOd5PlSilAQIDJiABIVggIWhAQyE5H-_9WM__87tYZq3yJPQ0rostof00z3MMSMoiWCCG3SuBh2TaTUHQDwd4CHyArPQ4EhKoScPbq0zxm1k_Dw")

///

let publicK = publicKey.slice(publicKey.length - 65).toString('hex')

///

const credentialIdLength = (authenticatorData[53] << 8) | authenticatorData[54]
    
let authenticatorD = Buffer.from([
    0x04,
    ...authenticatorData.slice(65 + credentialIdLength, 97 + credentialIdLength),
    ...authenticatorData.slice(100 + credentialIdLength, 132 + credentialIdLength)
]).toString('hex')
   
///

let publicKeykPrefixSlice = Buffer.from([0xa5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01, 0x21, 0x58, 0x20])
let startIndex = attestationObject.indexOf(publicKeykPrefixSlice)
    startIndex = startIndex + publicKeykPrefixSlice.length

let attestationO = Buffer.from([
    0x04,
    ...attestationObject.slice(startIndex, 32 + startIndex),
    ...attestationObject.slice(35 + startIndex, 67 + startIndex)
]).toString('hex')

///

console.log(`
    ${publicK}
    ${authenticatorD}
    ${attestationO}
`)


================================================
FILE: bun_tests/3.index.ts
================================================
import { Networks, Operation, Transaction } from '@stellar/stellar-sdk'

const txn_xdr = 'AAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ2gAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAABm9cbgAAAAAAAAAAEAAAAAAAAAGAAAAAAAAAAB15KLcsJwPM/q9+uf9O9NUEpVqLl5/JtFDqLIQrTRzmEAAAAIdHJhbnNmZXIAAAADAAAAEgAAAAHEqqtef1h9hZOQyrCuQRtZ3o8DHtvuSRoq1C8mc+UHHAAAABIAAAABStcRNXctVBwYQExJdAWbrBC3X+B3Ue9QkP4MJ8nhD7UAAAAKAAAAAAAAAAAAAAAAAJiWgAAAAAEAAAABAAAAAcSqq15/WH2Fk5DKsK5BG1nejwMe2+5JGirULyZz5QccVuXL7MuknWEAAkrxAAAAEQAAAAEAAAACAAAAEAAAAAEAAAACAAAADwAAAAdFZDI1NTE5AAAAAA0AAAAgawYrFjEXTyFLVqniIQebbdWimEk+WkHm4UAdwhtQENIAAAAQAAAAAQAAAAIAAAAPAAAAB0VkMjU1MTkAAAAADQAAAEB4a0Pf3RTJS6TOa69dJ7TG5noSSX3OiRRk8xucLNsxgkckcRyeWr18ir8EgFATxz4X2WvJGLMYNDu11ScujcANAAAAEAAAAAEAAAACAAAADwAAAAZQb2xpY3kAAAAAABIAAAABa07R4ERvYHyHhguMb1H1ScVe13IWchSNA5oUEwVRrK8AAAABAAAAAAAAAAHXkotywnA8z+r365/0701QSlWouXn8m0UOoshCtNHOYQAAAAh0cmFuc2ZlcgAAAAMAAAASAAAAAcSqq15/WH2Fk5DKsK5BG1nejwMe2+5JGirULyZz5QccAAAAEgAAAAFK1xE1dy1UHBhATEl0BZusELdf4HdR71CQ/gwnyeEPtQAAAAoAAAAAAAAAAAAAAAAAmJaAAAAAAAAAAAEAAAAAAAAAAQAAAAYAAAAB15KLcsJwPM/q9+uf9O9NUEpVqLl5/JtFDqLIQrTRzmEAAAAUAAAAAQAAAAMAAAAGAAAAAcSqq15/WH2Fk5DKsK5BG1nejwMe2+5JGirULyZz5QccAAAAFVbly+zLpJ1hAAAAAAAAAAYAAAAB15KLcsJwPM/q9+uf9O9NUEpVqLl5/JtFDqLIQrTRzmEAAAAQAAAAAQAAAAIAAAAPAAAAB0JhbGFuY2UAAAAAEgAAAAFK1xE1dy1UHBhATEl0BZusELdf4HdR71CQ/gwnyeEPtQAAAAEAAAAGAAAAAdeSi3LCcDzP6vfrn/TvTVBKVai5efybRQ6iyEK00c5hAAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAABxKqrXn9YfYWTkMqwrkEbWd6PAx7b7kkaKtQvJnPlBxwAAAABAAWL7QAAArgAAAIIAAAAAAACZwQAAAAA'

const txn = new Transaction(txn_xdr, Networks.TESTNET)

const op = txn.operations[0] as Operation.InvokeHostFunction

const sig = op.auth?.[0].credentials().address().signature()

console.log(sig?.map()?.[0].key().toXDR());

console.log(sig?.map()?.[1].key().toXDR());


================================================
FILE: bun_tests/4.index.ts
================================================
import { Address, xdr } from '@stellar/stellar-sdk'

const cred_xdr = 'AAAAAQAAAAF6gVF2E0+pwV5vWTPtG5VyHJ/X54JHeZUczj7CnvD12yDu4I6e6ZFHAAJ+ZgAAABAAAAABAAAAAQAAABEAAAABAAAAAQAAABAAAAABAAAAAgAAAA8AAAAHRWQyNTUxOQAAAAANAAAAIGsGKxYxF08hS1ap4iEHm23VophJPlpB5uFAHcIbUBDSAAAAEAAAAAEAAAACAAAADwAAAAdFZDI1NTE5AAAAAA0AAABATCGe41Xuovv1w5BXwfdupiYz86Ak2jdg432p8TNRTnHfShfVeiqxIKJr2mTHaCzxxoyNeA2h/4u/vxEOJUycBg=='

const credentials = xdr.SorobanCredentials.fromXDR(cred_xdr, 'base64')

xdr.SorobanCredentialsType.sorobanCredentialsAddress

console.log(
    credentials.switch() ===
    xdr.SorobanCredentialsType.sorobanCredentialsAddress()
);

const authEntryAddress = Address.fromScAddress(
    credentials.address().address(),
).toString();

console.log(authEntryAddress);


================================================
FILE: bun_tests/5.index.ts
================================================
// Build an assembled transaction manually

import { PasskeyClient } from 'passkey-kit'
import { AssembledTransaction } from '@stellar/stellar-sdk/minimal/contract';

const tx_xdr = 'AAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZ30AAAAAAAAAAQAAAAEAAAAAAAAAAAAAAABm+xLbAAAAAAAAAAEAAAAAAAAAGAAAAAAAAAAB15KLcsJwPM/q9+uf9O9NUEpVqLl5/JtFDqLIQrTRzmEAAAAIdHJhbnNmZXIAAAADAAAAEgAAAAGeKf+NLk3Jb5f2jCWLsZdKH31uJ94AOPposffyxd+2qAAAABIAAAABh/ZytVEXZeou5dLsuMEZdkkVCjaICnCTq0CmRionsIgAAAAKAAAAAAAAAAAAAAAAAJiWgAAAAAEAAAABAAAAAZ4p/40uTclvl/aMJYuxl0offW4n3gA4+mix9/LF37aoSOpiY5Ioi98AA0z8AAAAEAAAAAEAAAABAAAAEQAAAAEAAAABAAAAEAAAAAEAAAACAAAADwAAAAlTZWNwMjU2cjEAAAAAAAANAAAAFKrB2chB1uk2vswAZo5AakLnkqG/AAAAEAAAAAEAAAACAAAADwAAAAlTZWNwMjU2cjEAAAAAAAARAAAAAQAAAAMAAAAPAAAAEmF1dGhlbnRpY2F0b3JfZGF0YQAAAAAADQAAACXKupuc4WurWb3NCdWC5nW7akt6c3YA07IZIg7j6tAwSR0AAAAAAAAAAAAADwAAABBjbGllbnRfZGF0YV9qc29uAAAADQAAAJh7InR5cGUiOiJ3ZWJhdXRobi5nZXQiLCJjaGFsbGVuZ2UiOiJ5Zi1wZWlsRGlEN002cmhMZWZlMU8zQV80ZlE5STZOVGVIT0YwZ1ljVk00Iiwib3JpZ2luIjoiaHR0cHM6Ly9uZXh0LnBhc3NrZXkta2l0LWRlbW8ucGFnZXMuZGV2IiwiY3Jvc3NPcmlnaW4iOmZhbHNlfQAAAA8AAAAJc2lnbmF0dXJlAAAAAAAADQAAAEAtCj4OlKr5N+YX6ny5jYu5XXmGEq9adAQr/GSm9nPOqhDoqWDRL0yD466GjttJhp235xorK0sLB5xgWeLON2VMAAAAAAAAAAHXkotywnA8z+r365/0701QSlWouXn8m0UOoshCtNHOYQAAAAh0cmFuc2ZlcgAAAAMAAAASAAAAAZ4p/40uTclvl/aMJYuxl0offW4n3gA4+mix9/LF37aoAAAAEgAAAAGH9nK1URdl6i7l0uy4wRl2SRUKNogKcJOrQKZGKiewiAAAAAoAAAAAAAAAAAAAAAAAmJaAAAAAAAAAAAEAAAAAAAAAAQAAAAYAAAAB15KLcsJwPM/q9+uf9O9NUEpVqLl5/JtFDqLIQrTRzmEAAAAUAAAAAQAAAAMAAAAGAAAAAZ4p/40uTclvl/aMJYuxl0offW4n3gA4+mix9/LF37aoAAAAFUjqYmOSKIvfAAAAAAAAAAYAAAAB15KLcsJwPM/q9+uf9O9NUEpVqLl5/JtFDqLIQrTRzmEAAAAQAAAAAQAAAAIAAAAPAAAAB0JhbGFuY2UAAAAAEgAAAAGH9nK1URdl6i7l0uy4wRl2SRUKNogKcJOrQKZGKiewiAAAAAEAAAAGAAAAAdeSi3LCcDzP6vfrn/TvTVBKVai5efybRQ6iyEK00c5hAAAAEAAAAAEAAAACAAAADwAAAAdCYWxhbmNlAAAAABIAAAABnin/jS5NyW+X9owli7GXSh99bifeADj6aLH38sXftqgAAAABAAWL7QAAArgAAAIIAAAAAAACZxkAAAAA'

const contract = new PasskeyClient({
    contractId: '',
    rpcUrl: '',
    networkPassphrase: '',
})

const at = AssembledTransaction.fromXDR(contract.options, tx_xdr, contract.spec);

console.log(at.built);



================================================
FILE: bun_tests/6.index.ts
================================================
console.log(
    Buffer.from([0, 0, 0, 15, 0, 0, 0, 5, 115, 119, 95, 118, 49, 0, 0, 0]).toString('hex')
);


================================================
FILE: bun_tests/7.index.ts
================================================
// Test an XDR that deploys a contract

import { Networks, Operation, TransactionBuilder, xdr } from '@stellar/stellar-sdk/minimal';
import { AssembledTransaction, type AssembledTransactionOptions, type Tx } from '@stellar/stellar-sdk/minimal/contract';
import { Client as PasskeyClient } from 'passkey-kit-sdk';

let xdr_base64 = 'AAAAAgAAAAC4YTsgfBnWL+VK8itDD/gCnqtirv5cWHO3MXxqONNVmgAAAGQAESPAAAAAAQAAAAEAAAAAAAAAAAAAAABnrkStAAAAAAAAAAEAAAAAAAAAGAAAAAMAAAAAAAAAAAAAAAC4YTsgfBnWL+VK8itDD/gCnqtirv5cWHO3MXxqONNVmvsvbA+ypiNL9AWBaQhdhXtpba5tIv74SARYfnqYLTICAAAAAMH9pZirYl7himeZ8T6ddEuJwyaE/xqaJTNnneY4XZSXAAAAAwAAABIAAAABg53yKxwbQoljlymK88aXMGcZomvOAI8tWIoxYZ7dk3UAAAASAAAAAdeSi3LCcDzP6vfrn/TvTVBKVai5efybRQ6iyEK00c5hAAAAAwAAAAYAAAAAAAAAAAAAAAA=';

let wallet = new PasskeyClient({
    contractId: 'CC6XIO7LP5GZL6WEAEM2FH2MKTNZ7CL2JF4TKYYGLALLLTWKF5TNJD7U',
    networkPassphrase: Networks.TESTNET,
    rpcUrl: 'https://soroban-testnet.stellar.org',
})

const built = TransactionBuilder.fromXDR(xdr_base64, Networks.TESTNET);
const operation = built.operations[0] as Operation.InvokeHostFunction;
const op = Operation.invokeHostFunction({
    func: operation.func,
})

const tx = await AssembledTransaction.buildWithOp(op, {
    ...wallet.options,
    simulate: false
} as unknown as AssembledTransactionOptions); // buildWithOp(operation, wallet.options);

console.log(tx);


================================================
FILE: bun_tests/8.index.ts
================================================
import { Keypair, hash } from "@stellar/stellar-sdk";

const keypair = Keypair.fromRawEd25519Seed(hash(Buffer.from('kalepail')))

console.log(keypair.secret());
console.log(keypair.publicKey());



================================================
FILE: bun_tests/package.json
================================================
{
  "name": "tests",
  "module": "index.ts",
  "type": "module",
  "devDependencies": {
    "@types/bun": "latest",
    "passkey-kit": "link:passkey-kit"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  }
}


================================================
FILE: bun_tests/tsconfig.json
================================================
{
  "compilerOptions": {
    // Enable latest features
    "lib": ["ESNext", "DOM"],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}



================================================
FILE: contracts/Cargo.toml
================================================
[workspace]
resolver = "2"

members = ["smart-wallet", "smart-wallet-interface", "example-contract", "sample-policy"]

[workspace.dependencies]
soroban-sdk = "22"
serde = { version = "1", default-features = false }
serde-json-core = { version = "0.6.0", default-features = false }
sha256 = { version = "1.5.0" }
ed25519-dalek = { version = "1" }
base64 = "0.22.1"
stellar-strkey = { version = "0.0.13" }
smart-wallet = { path = "smart-wallet" }
smart-wallet-interface = { path = "smart-wallet-interface" }
example-contract = { path = "example-contract" }
sample-policy = { path = "sample-policy" }

[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "symbols"
debug-assertions = false
panic = "abort"
codegen-units = 1
lto = true



================================================
FILE: contracts/Makefile
================================================
export STELLAR_NETWORK=testnet
export STELLAR_ACCOUNT=default
# export STELLAR_NETWORK=vc
# export STELLAR_ACCOUNT=live

# TESTNET
export SMART_WALLET_WASM=ecd990f0b45ca6817149b6175f79b32efb442f35731985a084131e8265c4cd90

build:
	rm -rf out/
	rm -rf smart-wallet/target/wasm32-unknown-unknown/

	stellar contract build
		
	@cd smart-wallet && stellar contract build --package smart-wallet --out-dir ../out
	stellar contract optimize --wasm ./out/smart_wallet.wasm

upload:
	stellar contract upload --wasm ./out/smart_wallet.optimized.wasm --source $(STELLAR_ACCOUNT)

bindings:
	stellar contract bindings typescript --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC --network $(STELLAR_NETWORK) --output-dir ./out/sac-sdk --overwrite
	stellar contract bindings typescript --wasm ./target/wasm32-unknown-unknown/release/smart_wallet.wasm --network $(STELLAR_NETWORK) --output-dir ./out/passkey-kit-sdk --overwrite

fmt:
	@cd smart-wallet && cargo fmt --all

clean:
	rm -rf out/
	rm -rf smart-wallet/target/
	@cd smart-wallet && cargo clean


================================================
FILE: contracts/rust-toolchain.toml
================================================
[toolchain]
channel = "stable"
targets = ["wasm32-unknown-unknown"]
components = ["rustc", "cargo", "rustfmt", "clippy", "rust-src"]



================================================
FILE: contracts/example-contract/Cargo.toml
================================================
[package]
name = "example-contract"
version = "0.0.0"
authors = ["Stellar Development Foundation <info@stellar.org>"]
license = "Apache-2.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[features]
testutils = []

[dependencies]
soroban-sdk = { workspace = true }

[dev-dependencies]
soroban-sdk = { workspace = true, features = ["testutils"] }
smart-wallet = { workspace = true, features = ["testutils"] }


================================================
FILE: contracts/example-contract/src/lib.rs
================================================
#![no_std]

use soroban_sdk::{contract, contractimpl, token, Address, BytesN, Env};

#[contract]
pub struct Contract;

#[contractimpl]
impl Contract {
    pub fn deploy(env: Env, source: Address, wasm_hash: BytesN<32>) {
        env.deployer()
            .with_address(source, wasm_hash.clone())
            .deploy_v2(wasm_hash, ());
    }
    pub fn call(
        env: Env,
        sac: Address,
        from: Address,
        to: Address,
        amount: i128,
        // signer_key: SignerKey,
        // signer: Signer,
    ) {
        from.require_auth();
        token::Client::new(&env, &sac).transfer(&from, &to, &amount);
        token::Client::new(&env, &sac).transfer(&from, &to, &10_000_00);
        // smart_wallet::ContractClient::new(&env, &from).remove(&signer_key);
        // smart_wallet::ContractClient::new(&env, &from).add(&signer);
    }
}



================================================
FILE: contracts/sample-policy/Cargo.toml
================================================
[package]
name = "sample-policy"
version = "0.0.0"
authors = ["Stellar Development Foundation <info@stellar.org>"]
license = "Apache-2.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[features]
testutils = []

[dependencies]
soroban-sdk = { workspace = true }
smart-wallet-interface = { workspace = true }

[dev-dependencies]
soroban-sdk = { workspace = true, features = ["testutils"] }


================================================
FILE: contracts/sample-policy/src/lib.rs
================================================
#![no_std]

use smart_wallet_interface::{types::SignerKey, PolicyInterface};
use soroban_sdk::{
    auth::{Context, ContractContext},
    contract, contracterror, contractimpl, panic_with_error, symbol_short, Address, Env,
    TryFromVal, Vec,
};

#[contracterror]
#[derive(Copy, Clone, Debug, PartialEq)]
#[repr(u32)]
pub enum Error {
    NotAllowed = 1,
}

#[contract]
pub struct Contract;

#[contractimpl]
impl PolicyInterface for Contract {
    fn policy__(env: Env, _source: Address, _signer: SignerKey, contexts: Vec<Context>) {
        for context in contexts.iter() {
            match context {
                Context::Contract(ContractContext { fn_name, args, .. }) => {
                    if let Some(amount_val) = args.get(2) {
                        if let Ok(amount) = i128::try_from_val(&env, &amount_val) {
                            if fn_name == symbol_short!("transfer") && amount > 10_000_000 {
                                panic_with_error!(&env, Error::NotAllowed)
                            }
                        }
                    }
                }
                _ => panic_with_error!(&env, Error::NotAllowed),
            }
        }
    }
}



================================================
FILE: contracts/smart-wallet/Cargo.toml
================================================
[package]
name = "smart-wallet"
version = "0.4.5"
authors = ["Stellar Development Foundation <info@stellar.org>"]
license = "Apache-2.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[features]
testutils = []

[dependencies]
soroban-sdk = { workspace = true }
smart-wallet-interface = { workspace = true }
serde = { workspace = true, features = ["derive"] }
serde-json-core = { workspace = true }

[dev-dependencies]
soroban-sdk = { workspace = true, features = ["testutils"] }
stellar-strkey = { workspace = true }
ed25519-dalek = { workspace = true }
base64 = { workspace = true }
sha256 = { workspace = true }
sample-policy = { workspace = true, features = ["testutils"] }
example-contract = { workspace = true, features = ["testutils"] }


================================================
FILE: contracts/smart-wallet/src/base64_url.rs
================================================
// Ported from https://github.com/golang/go/blob/26b5783b72376acd0386f78295e678b9a6bff30e/src/encoding/base64/base64.go#L53-L192
//
// Modifications:
//    * Removed logic supporting padding.
//    * Hardcoded the Base64 URL alphabet.
//    * Use a fixed length pre-allocated destination.
//    * Ported to Rust.
//
// Original Copyright notice:
//
// Copyright (c) 2009 The Go Authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//    * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//    * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

const ALPHABET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";

pub fn encode(dst: &mut [u8], src: &[u8]) {
    let mut di: usize = 0;
    let mut si: usize = 0;
    let n = (src.len() / 3) * 3; // (.. / 3 * 3) to ensure a % 3 `n`

    while si < n {
        let val = (src[si] as usize) << 16 | (src[si + 1] as usize) << 8 | (src[si + 2] as usize);
        dst[di] = ALPHABET[val >> 18 & 0x3F];
        dst[di + 1] = ALPHABET[val >> 12 & 0x3F];
        dst[di + 2] = ALPHABET[val >> 6 & 0x3F];
        dst[di + 3] = ALPHABET[val & 0x3F];
        si += 3;
        di += 4;
    }

    let remain = src.len() - si;

    if remain == 0 {
        return;
    }

    let mut val = (src[si] as usize) << 16;

    if remain == 2 {
        val |= (src[si + 1] as usize) << 8;
    }

    dst[di] = ALPHABET[val >> 18 & 0x3F];
    dst[di + 1] = ALPHABET[val >> 12 & 0x3F];

    if remain == 2 {
        dst[di + 2] = ALPHABET[val >> 6 & 0x3F];
    }
}



================================================
FILE: contracts/smart-wallet/src/context.rs
================================================
use smart_wallet_interface::types::{Signatures, SignerKey, SignerLimits};
use soroban_sdk::{
    auth::{Context, ContractContext},
    Env, FromVal, Symbol,
};

use crate::signer::verify_signer_limit_keys;

pub fn verify_context(
    env: &Env,
    context: &Context,
    signer_key: &SignerKey,
    signer_limits: &SignerLimits,
    signatures: &Signatures,
) -> bool {
    match &signer_limits.0 {
        None => true, // Signer has no limits, it can do anything
        Some(signer_limits) => {
            if signer_limits.is_empty() {
                return true;
            }

            match context {
                Context::Contract(ContractContext {
                    contract,
                    fn_name,
                    args,
                }) => {
                    match signer_limits.get(contract.clone()) {
                        None => false, // signer limitations not met
                        Some(signer_limits_keys) => {
                            // If this signer has a smart wallet context limit, limit that context to only removing itself
                            if *contract == env.current_contract_address()
                                && *fn_name != Symbol::new(&env, "remove_signer")
                                || (*fn_name == Symbol::new(&env, "remove_signer")
                                    && SignerKey::from_val(env, &args.get_unchecked(0))
                                        != *signer_key)
                            {
                                return false; // self trying to do something other than remove itself
                            }

                            verify_signer_limit_keys(
                                env,
                                signer_key,
                                signatures,
                                &signer_limits_keys,
                                &context,
                            );

                            true
                        }
                    }
                }
                Context::CreateContractHostFn(_) => {
                    // Only signers with the smart wallet context signer limit can deploy contracts
                    match signer_limits.get(env.current_contract_address()) {
                        None => false, // signer limitations not met
                        Some(signer_limits_keys) => {
                            verify_signer_limit_keys(
                                env,
                                signer_key,
                                signatures,
                                &signer_limits_keys,
                                &context,
                            );

                            true
                        }
                    }
                }
                Context::CreateContractWithCtorHostFn(_) => {
                    // Only signers with the smart wallet context signer limit can deploy contracts
                    match signer_limits.get(env.current_contract_address()) {
                        None => false, // signer limitations not met
                        Some(signer_limits_keys) => {
                            verify_signer_limit_keys(
                                env,
                                signer_key,
                                signatures,
                                &signer_limits_keys,
                                &context,
                            );

                            true
                        }
                    }
                }
            }
        }
    }
}



================================================
FILE: contracts/smart-wallet/src/lib.rs
================================================
#![no_std]

use context::verify_context;
use signer::{get_signer_val_storage, process_signer, store_signer, verify_signer_expiration};
use smart_wallet_interface::{
    types::{Error, Signature, Signatures, Signer, SignerKey, SignerStorage, SignerVal},
    PolicyClient, SmartWalletInterface,
};
use soroban_sdk::{
    auth::{Context, CustomAccountInterface},
    contract, contractimpl,
    crypto::Hash,
    panic_with_error, symbol_short, BytesN, Env, Symbol, Vec,
};
use storage::extend_instance;
use verify::verify_secp256r1_signature;

mod base64_url;
mod context;
mod signer;
mod storage;
mod types;
mod verify;

#[path = "./tests/test.rs"]
mod test;
#[path = "./tests/test_extra.rs"]
mod test_extra;

#[contract]
pub struct Contract;

const EVENT_TAG: Symbol = symbol_short!("sw_v1");
const INITIALIZED: Symbol = symbol_short!("init");

#[contractimpl]
impl SmartWalletInterface for Contract {
    fn __constructor(env: Env, signer: Signer) {
        Self::add_signer(env, signer);
    }
    fn add_signer(env: Env, signer: Signer) {
        if env
            .storage()
            .instance()
            .get::<Symbol, bool>(&INITIALIZED)
            .unwrap_or(false)
        {
            env.current_contract_address().require_auth();
        } else {
            env.storage()
                .instance()
                .set::<Symbol, bool>(&INITIALIZED, &true);
        }

        let (signer_key, signer_val, signer_storage) = process_signer(signer);

        store_signer(&env, &signer_key, &signer_val, &signer_storage, false);

        extend_instance(&env);

        env.events().publish(
            (EVENT_TAG, symbol_short!("add"), signer_key),
            (signer_val, signer_storage),
        );
    }
    fn update_signer(env: Env, signer: Signer) {
        env.current_contract_address().require_auth();

        let (signer_key, signer_val, signer_storage) = process_signer(signer);

        store_signer(&env, &signer_key, &signer_val, &signer_storage, true);

        extend_instance(&env);

        env.events().publish(
            (EVENT_TAG, symbol_short!("update"), signer_key),
            (signer_val, signer_storage),
        );
    }
    fn remove_signer(env: Env, signer_key: SignerKey) {
        env.current_contract_address().require_auth();

        match get_signer_val_storage(&env, &signer_key, false) {
            Some((_, signer_storage)) => match signer_storage {
                SignerStorage::Persistent => {
                    env.storage().persistent().remove::<SignerKey>(&signer_key);
                }
                SignerStorage::Temporary => {
                    env.storage().temporary().remove::<SignerKey>(&signer_key);
                }
            },
            None => panic_with_error!(env, Error::NotFound),
        }

        extend_instance(&env);

        env.events()
            .publish((EVENT_TAG, symbol_short!("remove"), signer_key), ());
    }
    fn update_contract_code(env: Env, hash: BytesN<32>) {
        env.current_contract_address().require_auth();

        env.deployer().update_current_contract_wasm(hash);

        extend_instance(&env);
    }
}

#[contractimpl]
impl CustomAccountInterface for Contract {
    type Error = Error;
    type Signature = Signatures;

    #[allow(non_snake_case)]
    fn __check_auth(
        env: Env,
        signature_payload: Hash<32>,
        signatures: Signatures,
        auth_contexts: Vec<Context>,
    ) -> Result<(), Error> {
        // Check all contexts for an authorizing signature
        for context in auth_contexts.iter() {
            'check: loop {
                for (signer_key, _) in signatures.0.iter() {
                    if let Some((signer_val, _)) = get_signer_val_storage(&env, &signer_key, false)
                    {
                        let (signer_expiration, signer_limits) = match signer_val {
                            SignerVal::Policy(signer_expiration, signer_limits) => {
                                (signer_expiration, signer_limits)
                            }
                            SignerVal::Ed25519(signer_expiration, signer_limits) => {
                                (signer_expiration, signer_limits)
                            }
                            SignerVal::Secp256r1(_, signer_expiration, signer_limits) => {
                                (signer_expiration, signer_limits)
                            }
                        };

                        verify_signer_expiration(&env, signer_expiration);

                        if verify_context(&env, &context, &signer_key, &signer_limits, &signatures)
                        {
                            break 'check;
                        } else {
                            continue;
                        }
                    }
                }

                panic_with_error!(env, Error::MissingContext);
            }
        }

        // Check all signatures for a matching context
        for (signer_key, signature) in signatures.0.iter() {
            // This is probably the only right place to verify_signer_expiration for crypto keys

            match get_signer_val_storage(&env, &signer_key, true) {
                None => panic_with_error!(env, Error::NotFound),
                Some((signer_val, _)) => {
                    match signature {
                        Signature::Policy => {
                            // If there's a policy signer in the signatures map we call it as a full forward of this __check_auth's Vec<Context>
                            if let SignerKey::Policy(policy) = &signer_key {
                                PolicyClient::new(&env, policy).policy__(
                                    &env.current_contract_address(),
                                    &signer_key,
                                    &auth_contexts,
                                );
                                continue;
                            }

                            panic_with_error!(&env, Error::SignatureKeyValueMismatch)
                        }
                        Signature::Ed25519(signature) => {
                            if let SignerKey::Ed25519(public_key) = &signer_key {
                                env.crypto().ed25519_verify(
                                    &public_key,
                                    &signature_payload.clone().into(),
                                    &signature,
                                );
                                continue;
                            }

                            panic_with_error!(&env, Error::SignatureKeyValueMismatch)
                        }
                        Signature::Secp256r1(signature) => {
                            if let SignerVal::Secp256r1(public_key, _, _) = signer_val {
                                verify_secp256r1_signature(
                                    &env,
                                    &signature_payload,
                                    &public_key,
                                    signature,
                                );
                                continue;
                            }

                            panic_with_error!(&env, Error::SignatureKeyValueMismatch)
                        }
                    }
                }
            };
        }

        extend_instance(&env);

        Ok(())
    }
}



================================================
FILE: contracts/smart-wallet/src/signer.rs
================================================
use smart_wallet_interface::{
    types::{Error, Signatures, Signer, SignerExpiration, SignerKey, SignerStorage, SignerVal},
    PolicyClient,
};
use soroban_sdk::{auth::Context, panic_with_error, vec, Env, Vec};

use crate::{context::verify_context, storage::extend_signer_key};

pub fn process_signer(signer: Signer) -> (SignerKey, SignerVal, SignerStorage) {
    match signer {
        Signer::Policy(policy, signer_expiration, signer_limits, signer_storage) => (
            SignerKey::Policy(policy),
            SignerVal::Policy(signer_expiration, signer_limits),
            signer_storage,
        ),
        Signer::Ed25519(public_key, signer_expiration, signer_limits, signer_storage) => (
            SignerKey::Ed25519(public_key),
            SignerVal::Ed25519(signer_expiration, signer_limits),
            signer_storage,
        ),
        Signer::Secp256r1(id, public_key, signer_expiration, signer_limits, signer_storage) => (
            SignerKey::Secp256r1(id),
            SignerVal::Secp256r1(public_key, signer_expiration, signer_limits),
            signer_storage,
        ),
    }
}

pub fn store_signer(
    env: &Env,
    signer_key: &SignerKey,
    signer_val: &SignerVal,
    signer_storage: &SignerStorage,
    update: bool,
) {
    // Include this before the `.set` calls so it doesn't read them as previous values
    let previous_signer_val_and_storage: Option<(SignerVal, SignerStorage)> =
        get_signer_val_storage(env, signer_key, false);

    // Add and extend the signer key in the appropriate storage
    let is_persistent = match signer_storage {
        SignerStorage::Persistent => {
            env.storage()
                .persistent()
                .set::<SignerKey, SignerVal>(signer_key, signer_val);

            true
        }
        SignerStorage::Temporary => {
            env.storage()
                .temporary()
                .set::<SignerKey, SignerVal>(signer_key, signer_val);

            false
        }
    };

    extend_signer_key(env, signer_key, is_persistent);

    match previous_signer_val_and_storage {
        Some((_, previous_signer_storage)) => {
            // Panic if the signer key already exists and we're not update it
            if !update {
                panic_with_error!(env, Error::AlreadyExists);
            }

            // Remove signer key in the opposing storage if it exists
            match previous_signer_storage {
                SignerStorage::Persistent => {
                    if !is_persistent {
                        env.storage().persistent().remove::<SignerKey>(signer_key);
                    }
                }
                SignerStorage::Temporary => {
                    if is_persistent {
                        env.storage().temporary().remove::<SignerKey>(signer_key);
                    }
                }
            }
        }
        None => {
            // Panic if we're update a signer key that doesn't exist
            if update {
                panic_with_error!(env, Error::NotFound);
            }
        }
    }
}

pub fn get_signer_val_storage(
    env: &Env,
    signer_key: &SignerKey,
    extend_ttl: bool,
) -> Option<(SignerVal, SignerStorage)> {
    match env
        .storage()
        .temporary()
        .get::<SignerKey, SignerVal>(signer_key)
    {
        Some(signer_val) => {
            if extend_ttl {
                extend_signer_key(env, signer_key, false);
            }

            Some((signer_val, SignerStorage::Temporary))
        }
        None => {
            match env
                .storage()
                .persistent()
                .get::<SignerKey, SignerVal>(signer_key)
            {
                Some(signer_val) => {
                    if extend_ttl {
                        extend_signer_key(env, signer_key, true);
                    }

                    Some((signer_val, SignerStorage::Persistent))
                }
                None => None,
            }
        }
    }
}

pub fn verify_signer_expiration(env: &Env, signer_expiration: SignerExpiration) {
    if let Some(signer_expiration) = signer_expiration.0 {
        if env.ledger().sequence() > signer_expiration {
            // Note we're not removing this expired signer. Probably fine but storage will fill up with expired signers
            // This is fine from the protocol perspective because persistent entries will be archived and temporary entries will be evicted
            // However on the indexer side we'll want to filter out signers which are expired
            panic_with_error!(env, Error::SignerExpired);
        }
    }
}

pub fn verify_signer_limit_keys(
    env: &Env,
    signer_key: &SignerKey,
    signatures: &Signatures,
    signer_limits_keys: &Option<Vec<SignerKey>>,
    context: &Context,
) {
    if let Some(signer_limits_keys) = signer_limits_keys {
        for signer_limits_key in signer_limits_keys.iter() {
            // Policies SignerLimits don't need to exist in the signatures map, or be stored on the smart wallet for that matter, they can be adjacent as long as they pass their own policy__ check
            if let SignerKey::Policy(policy) = &signer_limits_key {
                // In the case of a policy signer in the SignerLimits map we need to verify it if that key has been saved to the smart wallet
                // NOTE watch out for infinity loops. If a policy calls itself this will indefinitely recurse
                if let Some((signer_limits_val, _)) =
                    get_signer_val_storage(env, &signer_limits_key, true)
                {
                    if let SignerVal::Policy(signer_expiration, signer_limits) = signer_limits_val {
                        verify_signer_expiration(env, signer_expiration);

                        if !verify_context(
                            env,
                            context,
                            &signer_limits_key,
                            &signer_limits,
                            signatures,
                        ) {
                            panic_with_error!(env, Error::FailedPolicySignerLimits)
                        }
                    }
                }

                PolicyClient::new(&env, policy).policy__(
                    &env.current_contract_address(),
                    signer_key,
                    &vec![env, context.clone()],
                );
                // For every other SignerLimits key, it must exist in the signatures map and thus exist as a signer on the smart wallet
            } else if !signatures.0.contains_key(signer_limits_key.clone()) {
                // if any required key is missing this contract invocation is invalid
                panic_with_error!(env, Error::FailedSignerLimits)
            }
        }
    }
}



================================================
FILE: contracts/smart-wallet/src/storage.rs
================================================
use smart_wallet_interface::types::SignerKey;
use soroban_sdk::Env;

const WEEK_OF_LEDGERS: u32 = 60 * 60 * 24 / 5 * 7;

pub fn extend_instance(env: &Env) {
    let max_ttl = env.storage().max_ttl();

    env.storage()
        .instance()
        .extend_ttl(max_ttl - WEEK_OF_LEDGERS, max_ttl);
}
pub fn extend_signer_key(env: &Env, signer_key: &SignerKey, persistent: bool) {
    let max_ttl = env.storage().max_ttl();

    if persistent {
        env.storage().persistent().extend_ttl::<SignerKey>(
            signer_key,
            max_ttl - WEEK_OF_LEDGERS,
            max_ttl,
        );
    } else {
        env.storage().temporary().extend_ttl::<SignerKey>(
            signer_key,
            max_ttl - WEEK_OF_LEDGERS,
            max_ttl,
        );
    }
}



================================================
FILE: contracts/smart-wallet/src/types.rs
================================================
use soroban_sdk::{contracterror, contracttype, Address, Bytes, BytesN, Map, Vec};

#[contracterror]
#[derive(Copy, Clone, Debug, PartialEq)]
#[repr(u32)]
pub enum Error {
    NotFound = 1,
    AlreadyExists = 2,
    MissingContext = 3,
    SignerExpired = 4,
    FailedSignerLimits = 5,
    FailedPolicySignerLimits = 6,
    SignatureKeyValueMismatch = 7,
    ClientDataJsonChallengeIncorrect = 8,
    JsonParseError = 9,
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub struct SignerExpiration(pub Option<u32>);

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
// Map of contexts this signer can authorize if present in the __check_auth auth_contexts list
// Map value is a list of SignerKeys which must all be present in the __check_auth signatures list in order for the signer to authorize the context
// e.g. a policy runs on a SAC token to check how much it's withdrawing and also requires a signature from an additional ed25519 signer
// e.g. an ed25519 signer can only be used to authorize a specific contract's invocations and no further keys are required
pub struct SignerLimits(pub Option<Map<Address, Option<Vec<SignerKey>>>>);

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub enum SignerStorage {
    Persistent,
    Temporary,
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub enum Signer {
    Policy(Address, SignerExpiration, SignerLimits, SignerStorage),
    Ed25519(BytesN<32>, SignerExpiration, SignerLimits, SignerStorage),
    Secp256r1(
        Bytes,
        BytesN<65>,
        SignerExpiration,
        SignerLimits,
        SignerStorage,
    ),
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub enum SignerKey {
    Policy(Address),
    Ed25519(BytesN<32>),
    Secp256r1(Bytes),
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub enum SignerVal {
    Policy(SignerExpiration, SignerLimits),
    Ed25519(SignerExpiration, SignerLimits),
    Secp256r1(BytesN<65>, SignerExpiration, SignerLimits),
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub struct Secp256r1Signature {
    pub authenticator_data: Bytes,
    pub client_data_json: Bytes,
    pub signature: BytesN<64>,
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub enum Signature {
    Policy,
    Ed25519(BytesN<64>),
    Secp256r1(Secp256r1Signature),
}

#[contracttype]
#[derive(Clone, Debug, PartialEq)]
pub struct Signatures(pub Map<SignerKey, Signature>);



================================================
FILE: contracts/smart-wallet/src/verify.rs
================================================
use smart_wallet_interface::types::{Error, Secp256r1Signature};
use soroban_sdk::{crypto::Hash, panic_with_error, BytesN, Env};

use crate::base64_url;

#[derive(serde::Deserialize)]
struct ClientDataJson<'a> {
    challenge: &'a str,
}

pub fn verify_secp256r1_signature(
    env: &Env,
    signature_payload: &Hash<32>,
    public_key: &BytesN<65>,
    signature: Secp256r1Signature,
) {
    let Secp256r1Signature {
        mut authenticator_data,
        client_data_json,
        signature,
    } = signature;

    authenticator_data.extend_from_array(&env.crypto().sha256(&client_data_json).to_array());

    env.crypto().secp256r1_verify(
        &public_key,
        &env.crypto().sha256(&authenticator_data),
        &signature,
    );

    // Parse the client data JSON, extracting the base64 url encoded challenge.
    let client_data_json = client_data_json.to_buffer::<1024>(); // <- TODO why 1024?
    let client_data_json = client_data_json.as_slice();
    let (client_data_json, _): (ClientDataJson, _) =
        serde_json_core::de::from_slice(client_data_json)
            .unwrap_or_else(|_| panic_with_error!(env, Error::JsonParseError));

    // Build what the base64 url challenge is expecting.
    let mut expected_challenge = [0u8; 43];

    base64_url::encode(&mut expected_challenge, &signature_payload.to_array());

    // Check that the challenge inside the client data JSON that was signed is identical to the expected challenge.
    // TODO is this check actually necessary or is the secp256r1_verify sufficient?
    if client_data_json.challenge.as_bytes() != expected_challenge {
        panic_with_error!(env, Error::ClientDataJsonChallengeIncorrect)
    }
}



================================================
FILE: contracts/smart-wallet/src/tests/test.rs
================================================
#![cfg(test)]

use std::println;
extern crate std;

use crate::{Contract, ContractClient};
use ed25519_dalek::{Keypair, Signer as _};
use example_contract::{Contract as ExampleContract, ContractClient as ExampleContractClient};
use sample_policy::Contract as PolicyContract;
use smart_wallet_interface::types::{
    Signature, Signatures, Signer, SignerExpiration, SignerKey, SignerLimits, SignerStorage,
};
use soroban_sdk::{
    map,
    testutils::EnvTestConfig,
    token, vec,
    xdr::{
        HashIdPreimage, HashIdPreimageSorobanAuthorization, InvokeContractArgs, Limits,
        SorobanAddressCredentials, SorobanAuthorizationEntry, SorobanAuthorizedFunction,
        SorobanAuthorizedInvocation, SorobanCredentials, ToXdr, VecM, WriteXdr,
    },
    Address, Bytes, BytesN, Env, String,
};
use stellar_strkey::{ed25519, Strkey};

#[test]
fn test() {
    let mut env: Env = Env::default();

    env.set_config(EnvTestConfig {
        capture_snapshot_at_drop: false,
    });

    let signature_expiration_ledger = env.ledger().sequence();
    let amount = 10_000_000i128;
    let evil_amount = 10_000_00i128;

    // Super Ed25519
    let super_ed25519_keypair = Keypair::from_bytes(&[
        88, 206, 67, 128, 240, 45, 168, 148, 191, 111, 180, 111, 104, 83, 214, 113, 78, 27, 55, 86,
        200, 247, 164, 163, 76, 236, 24, 208, 115, 40, 231, 255, 161, 115, 141, 114, 97, 125, 136,
        247, 117, 105, 60, 155, 144, 51, 216, 187, 185, 157, 18, 126, 169, 172, 15, 4, 148, 13,
        208, 144, 53, 12, 91, 78,
    ])
    .unwrap();

    let super_ed25519_strkey =
        Strkey::PublicKeyEd25519(ed25519::PublicKey(super_ed25519_keypair.public.to_bytes()));
    let super_ed25519 = Bytes::from_slice(&env, super_ed25519_strkey.to_string().as_bytes());
    let super_ed25519 = Address::from_string_bytes(&super_ed25519);

    let super_ed25519_bytes = super_ed25519.to_xdr(&env);
    let super_ed25519_bytes = super_ed25519_bytes.slice(super_ed25519_bytes.len() - 32..);
    let mut super_ed25519_array = [0u8; 32];
    super_ed25519_bytes.copy_into_slice(&mut super_ed25519_array);
    let super_ed25519_bytes = BytesN::from_array(&env, &super_ed25519_array);

    let super_ed25519_signer_key = SignerKey::Ed25519(super_ed25519_bytes.clone());
    //

    let wallet_address = env.register(
        Contract,
        (Signer::Ed25519(
            super_ed25519_bytes,
            SignerExpiration(None),
            SignerLimits(None),
            SignerStorage::Persistent,
        ),),
    );
    let wallet_client = ContractClient::new(&env, &wallet_address);

    let example_contract_address = env.register(ExampleContract, ());
    let example_contract_client = ExampleContractClient::new(&env, &example_contract_address);

    // SAC
    let sac_admin = Address::from_string(&String::from_str(
        &env,
        "GD7777777777777777777777777777777777777777777777777773DB",
    ));
    let sac = env.register_stellar_asset_contract_v2(sac_admin);
    let sac_address = sac.address();
    let sac_admin_client = token::StellarAssetClient::new(&env, &sac_address);
    let sac_client = token::Client::new(&env, &sac_address);
    //

    sac_admin_client
        .mock_all_auths()
        .mint(&wallet_address, &100_000_000);

    // Secp256r1
    // let secp256r1_id = Bytes::from_array(
    //     &env,
    //     &[
    //         243, 248, 216, 74, 226, 218, 85, 102, 196, 167, 14, 151, 124, 42, 73, 136, 138, 102,
    //         187, 140,
    //     ],
    // );
    // let secp256r1_public_key = BytesN::from_array(
    //     &env,
    //     &[
    //         4, 163, 142, 245, 242, 113, 55, 104, 189, 52, 128, 238, 206, 174, 194, 177, 4, 100,
    //         161, 243, 177, 255, 10, 53, 57, 194, 205, 45, 208, 10, 131, 167, 93, 44, 123, 126, 95,
    //         219, 207, 230, 175, 90, 96, 41, 121, 197, 127, 180, 74, 236, 160, 0, 60, 185, 211, 174,
    //         133, 215, 200, 208, 230, 51, 210, 94, 214,
    //     ],
    // );
    // let secp256r1_signer_key = SignerKey::Secp256r1(secp256r1_id.clone());
    // let secp246r1_signer = Signer::Secp256r1(
    //     secp256r1_id,
    //     secp256r1_public_key,
    //     SignerLimits(map![&env]),
    //     SignerStorage::Temporary,
    // );
    ////

    // Simple Ed25519
    let simple_ed25519_keypair = Keypair::from_bytes(&[
        149, 154, 40, 132, 13, 234, 167, 87, 182, 44, 152, 45, 242, 179, 187, 17, 139, 106, 49, 85,
        249, 235, 17, 248, 24, 170, 19, 164, 23, 117, 145, 252, 172, 35, 170, 26, 69, 15, 75, 127,
        192, 170, 166, 54, 68, 127, 218, 29, 130, 173, 159, 1, 253, 192, 48, 242, 80, 12, 55, 152,
        223, 122, 198, 96,
    ])
    .unwrap();

    let simple_ed25519_strkey =
        Strkey::PublicKeyEd25519(ed25519::PublicKey(simple_ed25519_keypair.public.to_bytes()));
    let simple_ed25519_address =
        Bytes::from_slice(&env, simple_ed25519_strkey.to_string().as_bytes());
    let simple_ed25519_address = Address::from_string_bytes(&simple_ed25519_address);

    let simple_ed25519_bytes = simple_ed25519_address.to_xdr(&env);
    let simple_ed25519_bytes = simple_ed25519_bytes.slice(simple_ed25519_bytes.len() - 32..);
    let mut simple_ed25519_array = [0u8; 32];
    simple_ed25519_bytes.copy_into_slice(&mut simple_ed25519_array);
    let simple_ed25519_bytes = BytesN::from_array(&env, &simple_ed25519_array);
    let simple_ed25519_signer_key = SignerKey::Ed25519(simple_ed25519_bytes.clone());
    //

    // Policy
    let sample_policy_address = env.register(PolicyContract, ());
    let sample_policy_signer_key = SignerKey::Policy(sample_policy_address.clone());
    //

    // Add signers to smart wallet
    // wallet_client.mock_all_auths().add(&Signer::Ed25519(
    //     super_ed25519_bytes,
    //     SignerLimits(map![&env]),
    //     SignerStorage::Persistent,
    // ));

    // wallet_client
    //     .mock_all_auths()
    //     .add(&secp246r1_signer.clone());

    wallet_client.mock_all_auths().add_signer(&Signer::Ed25519(
        simple_ed25519_bytes,
        SignerExpiration(None),
        SignerLimits(Some(map![
            &env,
            (
                sac_address.clone(),
                Some(vec![&env, sample_policy_signer_key.clone()])
            ),
            (example_contract_address.clone(), None,)
        ])),
        SignerStorage::Temporary,
    ));

    wallet_client.mock_all_auths().add_signer(&Signer::Policy(
        sample_policy_address.clone(),
        SignerExpiration(None),
        SignerLimits(Some(map![
            &env,
            (
                sac_address.clone(),
                Some(vec![&env, simple_ed25519_signer_key.clone()])
            ),
        ])),
        SignerStorage::Temporary,
    ));
    //

    let transfer_invocation = SorobanAuthorizedInvocation {
        function: SorobanAuthorizedFunction::ContractFn(InvokeContractArgs {
            contract_address: sac_address.clone().try_into().unwrap(),
            function_name: "transfer".try_into().unwrap(),
            args: std::vec![
                wallet_address.clone().try_into().unwrap(),
                sac_address.clone().try_into().unwrap(),
                amount.try_into().unwrap(),
            ]
            .try_into()
            .unwrap(),
        }),
        sub_invocations: VecM::default(),
    };

    let evil_transfer_invocation = SorobanAuthorizedInvocation {
        function: SorobanAuthorizedFunction::ContractFn(InvokeContractArgs {
            contract_address: sac_address.clone().try_into().unwrap(),
            function_name: "transfer".try_into().unwrap(),
            args: std::vec![
                wallet_address.clone().try_into().unwrap(),
                sac_address.clone().try_into().unwrap(),
                evil_amount.try_into().unwrap(),
            ]
            .try_into()
            .unwrap(),
        }),
        sub_invocations: VecM::default(),
    };

    // let remove_invocation = SorobanAuthorizedInvocation {
    //     function: SorobanAuthorizedFunction::ContractFn(InvokeContractArgs {
    //         contract_address: wallet_address.clone().try_into().unwrap(),
    //         function_name: "remove".try_into().unwrap(),
    //         args: std::vec![secp256r1_signer_key.clone().try_into().unwrap(),]
    //             .try_into()
    //             .unwrap(),
    //     }),
    //     sub_invocations: VecM::default(),
    // };

    // let add_invocation = SorobanAuthorizedInvocation {
    //     function: SorobanAuthorizedFunction::ContractFn(InvokeContractArgs {
    //         contract_address: wallet_address.clone().try_into().unwrap(),
    //         function_name: "add".try_into().unwrap(),
    //         args: std::vec![secp246r1_signer.clone().try_into().unwrap(),]
    //             .try_into()
    //             .unwrap(),
    //     }),
    //     sub_invocations: VecM::default(),
    // };

    let root_invocation = SorobanAuthorizedInvocation {
        function: SorobanAuthorizedFunction::ContractFn(InvokeContractArgs {
            contract_address: example_contract_address.clone().try_into().unwrap(),
            function_name: "call".try_into().unwrap(),
            args: std::vec![
                sac_address.clone().try_into().unwrap(),
                wallet_address.clone().try_into().unwrap(),
                sac_address.clone().try_into().unwrap(),
                amount.try_into().unwrap(),
                // remove_key.clone().try_into().unwrap(),
                // add_signer.clone().try_into().unwrap(),
            ]
            .try_into()
            .unwrap(),
        }),
        sub_invocations: std::vec![
            transfer_invocation.clone(),
            evil_transfer_invocation.clone(),
            // remove_invocation.clone(),
            // add_invocation.clone(),
        ]
        .try_into()
        .unwrap(),
    };

    let payload = HashIdPreimage::SorobanAuthorization(HashIdPreimageSorobanAuthorization {
        network_id: env.ledger().network_id().to_array().into(),
        nonce: 3,
        signature_expiration_ledger,
        invocation: root_invocation.clone(),
    });
    let payload = payload.to_xdr(Limits::none()).unwrap();
    let payload = Bytes::from_slice(&env, payload.as_slice());
    let payload = env.crypto().sha256(&payload);

    // let super_ed25519_signature = Signature::Ed25519(BytesN::from_array(
    //     &env,
    //     &super_ed25519_keypair
    //         .sign(payload.to_array().as_slice())
    //         .to_bytes(),
    // ));

    let simple_ed25519_signature = Signature::Ed25519(BytesN::from_array(
        &env,
        &simple_ed25519_keypair
            .sign(payload.to_array().as_slice())
            .to_bytes(),
    ));

    let root_auth = SorobanAuthorizationEntry {
        credentials: SorobanCredentials::Address(SorobanAddressCredentials {
            address: wallet_address.clone().try_into().unwrap(),
            nonce: 3,
            signature_expiration_ledger,
            signature: Signatures(map![
                &env,
                (simple_ed25519_signer_key.clone(), simple_ed25519_signature),
                // (
                //     sample_policy_signer_key.clone(),
                //     None
                // ),
                // (
                //     super_ed25519_signer_key.clone(),
                //     Some(super_ed25519_signature)
                // ),
            ])
            .try_into()
            .unwrap(),
        }),
        root_invocation: root_invocation.clone(),
    };

    env.budget().reset_default();

    example_contract_client.set_auths(&[root_auth]).call(
        &sac_address,
        &wallet_address,
        &sac_address,
        &amount,
        // &remove_key,
        // &add_signer,
    );

    // Loose
    // Cpu limit: 100000000; used: 1011983
    // Mem limit: 41943040; used: 106096

    // Careful
    // Cpu limit: 100000000; used: 999991
    // Mem limit: 41943040; used: 86036

    println!("{:?}", env.budget().print());
}



================================================
FILE: contracts/smart-wallet/src/tests/test_extra.rs
================================================
#![cfg(test)]

use std::println;
extern crate std;

use example_contract::{Contract as ExampleContract, ContractClient as ExampleContractClient};
use smart_wallet_interface::types::{
    Signature, Signatures, Signer, SignerExpiration, SignerKey, SignerLimits, SignerStorage,
};
use soroban_sdk::{
    map, symbol_short,
    testutils::EnvTestConfig,
    xdr::{
        ContractExecutable, ContractIdPreimage, ContractIdPreimageFromAddress,
        CreateContractArgsV2, Hash, HashIdPreimage, HashIdPreimageSorobanAuthorization, Limits,
        ScAddress, ScVal, SorobanAddressCredentials, SorobanAuthorizationEntry,
        SorobanAuthorizedFunction, SorobanAuthorizedInvocation, SorobanCredentials, ToXdr, Uint256,
        VecM, WriteXdr,
    },
    Address, Bytes, BytesN, Env,
};
use stellar_strkey::{ed25519, Strkey};

use crate::{Contract, ContractClient};
use ed25519_dalek::{Keypair, Signer as _};

use base64::{engine::general_purpose::URL_SAFE, Engine as _};

mod sample_policy {
    use crate::types::SignerKey;
    use soroban_sdk::auth::Context;
    soroban_sdk::contractimport!(
        file = "../target/wasm32-unknown-unknown/release/sample_policy.wasm"
    );
}

#[test]
fn test() {
    let env = Env::default();

    let test = symbol_short!("sw_v1");

    println!("{:?}", test.to_xdr(&env));
}

#[test]
fn test_deploy_contract() {
    let mut env: Env = Env::default();

    env.set_config(EnvTestConfig {
        capture_snapshot_at_drop: false,
    });

    let signature_expiration_ledger = env.ledger().sequence();

    // Super Ed25519
    let super_ed25519_keypair = Keypair::from_bytes(&[
        88, 206, 67, 128, 240, 45, 168, 148, 191, 111, 180, 111, 104, 83, 214, 113, 78, 27, 55, 86,
        200, 247, 164, 163, 76, 236, 24, 208, 115, 40, 231, 255, 161, 115, 141, 114, 97, 125, 136,
        247, 117, 105, 60, 155, 144, 51, 216, 187, 185, 157, 18, 126, 169, 172, 15, 4, 148, 13,
        208, 144, 53, 12, 91, 78,
    ])
    .unwrap();

    let super_ed25519_strkey =
        Strkey::PublicKeyEd25519(ed25519::PublicKey(super_ed25519_keypair.public.to_bytes()));
    let super_ed25519 = Bytes::from_slice(&env, super_ed25519_strkey.to_string().as_bytes());
    let super_ed25519 = Address::from_string_bytes(&super_ed25519);

    let super_ed25519_bytes = super_ed25519.to_xdr(&env);
    let super_ed25519_bytes = super_ed25519_bytes.slice(super_ed25519_bytes.len() - 32..);
    let mut super_ed25519_array = [0u8; 32];
    super_ed25519_bytes.copy_into_slice(&mut super_ed25519_array);
    let super_ed25519_bytes = BytesN::from_array(&env, &super_ed25519_array);

    let super_ed25519_signer_key = SignerKey::Ed25519(super_ed25519_bytes.clone());
    //

    let wallet_address = env.register(
        Contract,
        (Signer::Ed25519(
            super_ed25519_bytes,
            SignerExpiration(None),
            SignerLimits(None),
            SignerStorage::Persistent,
        ),),
    );
    // let wallet_client = ContractClient::new(&env, &wallet_address);

    let example_contract_address = env.register(ExampleContract, ());
    let example_contract_client = ExampleContractClient::new(&env, &example_contract_address);

    let wasm_hash = env.deployer().upload_contract_wasm(sample_policy::WASM);

    let wallet_address_bytes = wallet_address.clone().to_xdr(&env);
    let wallet_address_bytes = wallet_address_bytes.slice(wallet_address_bytes.len() - 32..);
    let mut wallet_address_array = [0u8; 32];
    wallet_address_bytes.copy_into_slice(&mut wallet_address_array);

    let root_invocation = SorobanAuthorizedInvocation {
        function: SorobanAuthorizedFunction::CreateContractV2HostFn(CreateContractArgsV2 {
            contract_id_preimage: ContractIdPreimage::Address(ContractIdPreimageFromAddress {
                address: ScAddress::Contract(Hash::from(wallet_address_array)),
                salt: Uint256(wasm_hash.to_array()),
            }),
            executable: ContractExecutable::Wasm(Hash::from(wasm_hash.to_array())),
            constructor_args: VecM::default(),
        }),
        sub_invocations: VecM::default(),
    };

    let payload = HashIdPreimage::SorobanAuthorization(HashIdPreimageSorobanAuthorization {
        network_id: env.ledger().network_id().to_array().into(),
        nonce: 0,
        signature_expiration_ledger,
        invocation: root_invocation.clone(),
    });
    let payload = payload.to_xdr(Limits::none()).unwrap();
    let payload = Bytes::from_slice(&env, payload.as_slice());
    let payload = env.crypto().sha256(&payload);

    let super_ed25519_signature = Signature::Ed25519(BytesN::from_array(
        &env,
        &super_ed25519_keypair
            .sign(payload.to_array().as_slice())
            .to_bytes(),
    ));

    let root_auth = SorobanAuthorizationEntry {
        credentials: SorobanCredentials::Address(SorobanAddressCredentials {
            address: wallet_address.clone().try_into().unwrap(),
            nonce: 0,
            signature_expiration_ledger,
            signature: Signatures(map![
                &env,
                (super_ed25519_signer_key.clone(), super_ed25519_signature),
            ])
            .try_into()
            .unwrap(),
        }),
        root_invocation: root_invocation.clone(),
    };

    example_contract_client
        .set_auths(&[root_auth])
        .deploy(&wallet_address, &wasm_hash);
}

#[test]
fn who_am_i() {
    let env: Env = Env::default();

    let none = None::<Address>;
    let none = none.to_xdr(&env);
    let mut none_bytes: [u8; 4] = [0; 4];

    none.copy_into_slice(&mut none_bytes);

    println!("{:?}", URL_SAFE.encode(none_bytes));
    println!("{:?}", ScVal::Void.to_xdr_base64(Limits::none()).unwrap());
}



================================================
FILE: contracts/smart-wallet-interface/Cargo.toml
================================================
[package]
name = "smart-wallet-interface"
version = "0.4.5"
authors = ["Stellar Development Foundation <info@stellar.org>"]
license = "Apache-2.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]
doctest = false

[features]
testutils = []

[dependencies]
soroban-sdk = { workspace = true }


================================================
FILE: contracts/smart-wallet-interface/src/lib.rs
================================================
#![no_std]

use soroban_sdk::{auth::Context, contractclient, Address, BytesN, Env, Vec};
use types::{Signer, SignerKey};

pub mod types;

#[contractclient(name = "SmartWalletClient")]
pub trait SmartWalletInterface {
    fn __constructor(env: Env, signer: Signer);
    fn add_signer(env: Env, signer: Signer);
    fn update_signer(env: Env, signer: Signer);
    fn remove_signer(env: Env, signer_key: SignerKey);
    fn update_contract_code(env: Env, hash: BytesN<32>);
}

#[contractclient(name = "PolicyClient")]
pub trait PolicyInterface {
    fn policy__(env: Env, source: Address, signer: SignerKey, contexts: Vec<Context>);
}



================================================
FILE: contracts/smart-wallet-interface/src/types.rs
================================================
use soroban_sdk::{contracterror, contracttype, Address, Bytes, BytesN, Map, Vec};

#[contracterror(export = false)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[repr(u32)]
pub enum Error {
    NotFound = 1,
    AlreadyExists = 2,
    MissingContext = 3,
    SignerExpired = 4,
    FailedSignerLimits = 5,
    FailedPolicySignerLimits = 6,
    SignatureKeyValueMismatch = 7,
    ClientDataJsonChallengeIncorrect = 8,
    JsonParseError = 9,
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub struct SignerExpiration(pub Option<u32>);

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
// Map of contexts this signer can authorize if present in the __check_auth auth_contexts list
// Map value is a list of SignerKeys which must all be present in the __check_auth signatures list in order for the signer to authorize the context
// e.g. a policy runs on a SAC token to check how much it's withdrawing and also requires a signature from an additional ed25519 signer
// e.g. an ed25519 signer can only be used to authorize a specific contract's invocations and no further keys are required
pub struct SignerLimits(pub Option<Map<Address, Option<Vec<SignerKey>>>>);

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub enum SignerStorage {
    Persistent,
    Temporary,
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub enum Signer {
    Policy(Address, SignerExpiration, SignerLimits, SignerStorage),
    Ed25519(BytesN<32>, SignerExpiration, SignerLimits, SignerStorage),
    Secp256r1(
        Bytes,
        BytesN<65>,
        SignerExpiration,
        SignerLimits,
        SignerStorage,
    ),
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub enum SignerKey {
    Policy(Address),
    Ed25519(BytesN<32>),
    Secp256r1(Bytes),
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub enum SignerVal {
    Policy(SignerExpiration, SignerLimits),
    Ed25519(SignerExpiration, SignerLimits),
    Secp256r1(BytesN<65>, SignerExpiration, SignerLimits),
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub struct Secp256r1Signature {
    pub authenticator_data: Bytes,
    pub client_data_json: Bytes,
    pub signature: BytesN<64>,
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub enum Signature {
    Policy,
    Ed25519(BytesN<64>),
    Secp256r1(Secp256r1Signature),
}

#[contracttype(export = false)]
#[derive(Clone, Debug, PartialEq)]
pub struct Signatures(pub Map<SignerKey, Signature>);



================================================
FILE: demo/README.md
================================================
# Svelte + TS + Vite

This template should help get you started developing with Svelte and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).

## Need an official Svelte framework?

Check out [SvelteKit](https://github.com/sveltejs/kit#readme), which is also powered by Vite. Deploy anywhere with its serverless-first approach and adapt to various platforms, with out of the box support for TypeScript, SCSS, and Less, and easily-added support for mdsvex, GraphQL, PostCSS, Tailwind CSS, and more.

## Technical considerations

**Why use this over SvelteKit?**

- It brings its own routing solution which might not be preferable for some users.
- It is first and foremost a framework that just happens to use Vite under the hood, not a Vite app.

This template contains as little as possible to get started with Vite + TypeScript + Svelte, while taking into account the developer experience with regards to HMR and intellisense. It demonstrates capabilities on par with the other `create-vite` templates and is a good starting point for beginners dipping their toes into a Vite + Svelte project.

Should you later need the extended capabilities and extensibility provided by SvelteKit, the template has been structured similarly to SvelteKit so that it is easy to migrate.

**Why `global.d.ts` instead of `compilerOptions.types` inside `jsconfig.json` or `tsconfig.json`?**

Setting `compilerOptions.types` shuts out all other types not explicitly listed in the configuration. Using triple-slash references keeps the default TypeScript setting of accepting type information from the entire workspace, while also adding `svelte` and `vite/client` type information.

**Why include `.vscode/extensions.json`?**

Other templates indirectly recommend extensions via the README, but this file allows VS Code to prompt the user to install the recommended extension upon opening the project.

**Why enable `allowJs` in the TS template?**

While `allowJs: false` would indeed prevent the use of `.js` files in the project, it does not prevent the use of JavaScript syntax in `.svelte` files. In addition, it would force `checkJs: false`, bringing the worst of both worlds: not being able to guarantee the entire codebase is TypeScript, and also having worse typechecking for the existing JavaScript. In addition, there are valid use cases in which a mixed codebase may be relevant.

**Why is HMR not preserving my local component state?**

HMR state preservation comes with a number of gotchas! It has been disabled by default in both `svelte-hmr` and `@sveltejs/vite-plugin-svelte` due to its often surprising behavior. You can read the details [here](https://github.com/rixo/svelte-hmr#svelte-hmr).

If you have state that's important to retain within a component, consider creating an external store which would not be replaced by HMR.

```ts
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)
```



================================================
FILE: demo/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + Svelte + TS</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>



================================================
FILE: demo/package.json
================================================
{
  "type": "module",
  "scripts": {
    "dev": "vite",
    "dev:prod": "vite --mode production",
    "start": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "check": "svelte-check --tsconfig ./tsconfig.json"
  },
  "devDependencies": {
    "@stellar/stellar-sdk": "13.3.0",
    "@sveltejs/vite-plugin-svelte": "^3.1.2",
    "@tsconfig/svelte": "^5.0.4",
    "base64url": "^3.0.1",
    "buffer": "^6.0.3",
    "passkey-kit": "link:..",
    "svelte": "^4.2.19",
    "svelte-check": "^4.1.7",
    "tslib": "^2.8.1",
    "typescript": "^5.8.3",
    "vite": "^5.4.14",
    "vite-plugin-filter-replace": "^0.1.14"
  },
  "pnpm": {
    "overrides": {
      "@stellar/stellar-sdk": "$@stellar/stellar-sdk"
    }
  }
}



================================================
FILE: demo/pnpm-lock.yaml
================================================
lockfileVersion: '9.0'

settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

overrides:
  '@stellar/stellar-sdk': 13.3.0

importers:

  .:
    devDependencies:
      '@stellar/stellar-sdk':
        specifier: 13.3.0
        version: 13.3.0
      '@sveltejs/vite-plugin-svelte':
        specifier: ^3.1.2
        version: 3.1.2(svelte@4.2.19)(vite@5.4.14)
      '@tsconfig/svelte':
        specifier: ^5.0.4
        version: 5.0.4
      base64url:
        specifier: ^3.0.1
        version: 3.0.1
      buffer:
        specifier: ^6.0.3
        version: 6.0.3
      passkey-kit:
        specifier: link:..
        version: link:..
      svelte:
        specifier: ^4.2.19
        version: 4.2.19
      svelte-check:
        specifier: ^4.1.7
        version: 4.1.7(svelte@4.2.19)(typescript@5.8.3)
      tslib:
        specifier: ^2.8.1
        version: 2.8.1
      typescript:
        specifier: ^5.8.3
        version: 5.8.3
      vite:
        specifier: ^5.4.14
        version: 5.4.14
      vite-plugin-filter-replace:
        specifier: ^0.1.14
        version: 0.1.14

packages:

  '@ampproject/remapping@2.3.0':
    resolution: {integrity: sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==}
    engines: {node: '>=6.0.0'}

  '@esbuild/aix-ppc64@0.21.5':
    resolution: {integrity: sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [aix]

  '@esbuild/android-arm64@0.21.5':
    resolution: {integrity: sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [android]

  '@esbuild/android-arm@0.21.5':
    resolution: {integrity: sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [android]

  '@esbuild/android-x64@0.21.5':
    resolution: {integrity: sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [android]

  '@esbuild/darwin-arm64@0.21.5':
    resolution: {integrity: sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [darwin]

  '@esbuild/darwin-x64@0.21.5':
    resolution: {integrity: sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [darwin]

  '@esbuild/freebsd-arm64@0.21.5':
    resolution: {integrity: sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [freebsd]

  '@esbuild/freebsd-x64@0.21.5':
    resolution: {integrity: sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [freebsd]

  '@esbuild/linux-arm64@0.21.5':
    resolution: {integrity: sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [linux]

  '@esbuild/linux-arm@0.21.5':
    resolution: {integrity: sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==}
    engines: {node: '>=12'}
    cpu: [arm]
    os: [linux]

  '@esbuild/linux-ia32@0.21.5':
    resolution: {integrity: sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [linux]

  '@esbuild/linux-loong64@0.21.5':
    resolution: {integrity: sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==}
    engines: {node: '>=12'}
    cpu: [loong64]
    os: [linux]

  '@esbuild/linux-mips64el@0.21.5':
    resolution: {integrity: sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==}
    engines: {node: '>=12'}
    cpu: [mips64el]
    os: [linux]

  '@esbuild/linux-ppc64@0.21.5':
    resolution: {integrity: sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==}
    engines: {node: '>=12'}
    cpu: [ppc64]
    os: [linux]

  '@esbuild/linux-riscv64@0.21.5':
    resolution: {integrity: sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==}
    engines: {node: '>=12'}
    cpu: [riscv64]
    os: [linux]

  '@esbuild/linux-s390x@0.21.5':
    resolution: {integrity: sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==}
    engines: {node: '>=12'}
    cpu: [s390x]
    os: [linux]

  '@esbuild/linux-x64@0.21.5':
    resolution: {integrity: sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [linux]

  '@esbuild/netbsd-x64@0.21.5':
    resolution: {integrity: sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [netbsd]

  '@esbuild/openbsd-x64@0.21.5':
    resolution: {integrity: sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [openbsd]

  '@esbuild/sunos-x64@0.21.5':
    resolution: {integrity: sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [sunos]

  '@esbuild/win32-arm64@0.21.5':
    resolution: {integrity: sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==}
    engines: {node: '>=12'}
    cpu: [arm64]
    os: [win32]

  '@esbuild/win32-ia32@0.21.5':
    resolution: {integrity: sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==}
    engines: {node: '>=12'}
    cpu: [ia32]
    os: [win32]

  '@esbuild/win32-x64@0.21.5':
    resolution: {integrity: sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==}
    engines: {node: '>=12'}
    cpu: [x64]
    os: [win32]

  '@jridgewell/gen-mapping@0.3.8':
    resolution: {integrity: sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/resolve-uri@3.1.2':
    resolution: {integrity: sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/set-array@1.2.1':
    resolution: {integrity: sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==}
    engines: {node: '>=6.0.0'}

  '@jridgewell/sourcemap-codec@1.5.0':
    resolution: {integrity: sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==}

  '@jridgewell/trace-mapping@0.3.25':
    resolution: {integrity: sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==}

  '@rollup/rollup-android-arm-eabi@4.36.0':
    resolution: {integrity: sha512-jgrXjjcEwN6XpZXL0HUeOVGfjXhPyxAbbhD0BlXUB+abTOpbPiN5Wb3kOT7yb+uEtATNYF5x5gIfwutmuBA26w==}
    cpu: [arm]
    os: [android]

  '@rollup/rollup-android-arm64@4.36.0':
    resolution: {integrity: sha512-NyfuLvdPdNUfUNeYKUwPwKsE5SXa2J6bCt2LdB/N+AxShnkpiczi3tcLJrm5mA+eqpy0HmaIY9F6XCa32N5yzg==}
    cpu: [arm64]
    os: [android]

  '@rollup/rollup-darwin-arm64@4.36.0':
    resolution: {integrity: sha512-JQ1Jk5G4bGrD4pWJQzWsD8I1n1mgPXq33+/vP4sk8j/z/C2siRuxZtaUA7yMTf71TCZTZl/4e1bfzwUmFb3+rw==}
    cpu: [arm64]
    os: [darwin]

  '@rollup/rollup-darwin-x64@4.36.0':
    resolution: {integrity: sha512-6c6wMZa1lrtiRsbDziCmjE53YbTkxMYhhnWnSW8R/yqsM7a6mSJ3uAVT0t8Y/DGt7gxUWYuFM4bwWk9XCJrFKA==}
    cpu: [x64]
    os: [darwin]

  '@rollup/rollup-freebsd-arm64@4.36.0':
    resolution: {integrity: sha512-KXVsijKeJXOl8QzXTsA+sHVDsFOmMCdBRgFmBb+mfEb/7geR7+C8ypAml4fquUt14ZyVXaw2o1FWhqAfOvA4sg==}
    cpu: [arm64]
    os: [freebsd]

  '@rollup/rollup-freebsd-x64@4.36.0':
    resolution: {integrity: sha512-dVeWq1ebbvByI+ndz4IJcD4a09RJgRYmLccwlQ8bPd4olz3Y213uf1iwvc7ZaxNn2ab7bjc08PrtBgMu6nb4pQ==}
    cpu: [x64]
    os: [freebsd]

  '@rollup/rollup-linux-arm-gnueabihf@4.36.0':
    resolution: {integrity: sha512-bvXVU42mOVcF4le6XSjscdXjqx8okv4n5vmwgzcmtvFdifQ5U4dXFYaCB87namDRKlUL9ybVtLQ9ztnawaSzvg==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm-musleabihf@4.36.0':
    resolution: {integrity: sha512-JFIQrDJYrxOnyDQGYkqnNBtjDwTgbasdbUiQvcU8JmGDfValfH1lNpng+4FWlhaVIR4KPkeddYjsVVbmJYvDcg==}
    cpu: [arm]
    os: [linux]

  '@rollup/rollup-linux-arm64-gnu@4.36.0':
    resolution: {integrity: sha512-KqjYVh3oM1bj//5X7k79PSCZ6CvaVzb7Qs7VMWS+SlWB5M8p3FqufLP9VNp4CazJ0CsPDLwVD9r3vX7Ci4J56A==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-arm64-musl@4.36.0':
    resolution: {integrity: sha512-QiGnhScND+mAAtfHqeT+cB1S9yFnNQ/EwCg5yE3MzoaZZnIV0RV9O5alJAoJKX/sBONVKeZdMfO8QSaWEygMhw==}
    cpu: [arm64]
    os: [linux]

  '@rollup/rollup-linux-loongarch64-gnu@4.36.0':
    resolution: {integrity: sha512-1ZPyEDWF8phd4FQtTzMh8FQwqzvIjLsl6/84gzUxnMNFBtExBtpL51H67mV9xipuxl1AEAerRBgBwFNpkw8+Lg==}
    cpu: [loong64]
    os: [linux]

  '@rollup/rollup-linux-powerpc64le-gnu@4.36.0':
    resolution: {integrity: sha512-VMPMEIUpPFKpPI9GZMhJrtu8rxnp6mJR3ZzQPykq4xc2GmdHj3Q4cA+7avMyegXy4n1v+Qynr9fR88BmyO74tg==}
    cpu: [ppc64]
    os: [linux]

  '@rollup/rollup-linux-riscv64-gnu@4.36.0':
    resolution: {integrity: sha512-ttE6ayb/kHwNRJGYLpuAvB7SMtOeQnVXEIpMtAvx3kepFQeowVED0n1K9nAdraHUPJ5hydEMxBpIR7o4nrm8uA==}
    cpu: [riscv64]
    os: [linux]

  '@rollup/rollup-linux-s390x-gnu@4.36.0':
    resolution: {integrity: sha512-4a5gf2jpS0AIe7uBjxDeUMNcFmaRTbNv7NxI5xOCs4lhzsVyGR/0qBXduPnoWf6dGC365saTiwag8hP1imTgag==}
    cpu: [s390x]
    os: [linux]

  '@rollup/rollup-linux-x64-gnu@4.36.0':
    resolution: {integrity: sha512-5KtoW8UWmwFKQ96aQL3LlRXX16IMwyzMq/jSSVIIyAANiE1doaQsx/KRyhAvpHlPjPiSU/AYX/8m+lQ9VToxFQ==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-linux-x64-musl@4.36.0':
    resolution: {integrity: sha512-sycrYZPrv2ag4OCvaN5js+f01eoZ2U+RmT5as8vhxiFz+kxwlHrsxOwKPSA8WyS+Wc6Epid9QeI/IkQ9NkgYyQ==}
    cpu: [x64]
    os: [linux]

  '@rollup/rollup-win32-arm64-msvc@4.36.0':
    resolution: {integrity: sha512-qbqt4N7tokFwwSVlWDsjfoHgviS3n/vZ8LK0h1uLG9TYIRuUTJC88E1xb3LM2iqZ/WTqNQjYrtmtGmrmmawB6A==}
    cpu: [arm64]
    os: [win32]

  '@rollup/rollup-win32-ia32-msvc@4.36.0':
    resolution: {integrity: sha512-t+RY0JuRamIocMuQcfwYSOkmdX9dtkr1PbhKW42AMvaDQa+jOdpUYysroTF/nuPpAaQMWp7ye+ndlmmthieJrQ==}
    cpu: [ia32]
    os: [win32]

  '@rollup/rollup-win32-x64-msvc@4.36.0':
    resolution: {integrity: sha512-aRXd7tRZkWLqGbChgcMMDEHjOKudo1kChb1Jt1IfR8cY/KIpgNviLeJy5FUb9IpSuQj8dU2fAYNMPW/hLKOSTw==}
    cpu: [x64]
    os: [win32]

  '@stellar/js-xdr@3.1.2':
    resolution: {integrity: sha512-VVolPL5goVEIsvuGqDc5uiKxV03lzfWdvYg1KikvwheDmTBO68CKDji3bAZ/kppZrx5iTA8z3Ld5yuytcvhvOQ==}

  '@stellar/stellar-base@13.1.0':
    resolution: {integrity: sha512-90EArG+eCCEzDGj3OJNoCtwpWDwxjv+rs/RNPhvg4bulpjN/CSRj+Ys/SalRcfM4/WRC5/qAfjzmJBAuquWhkA==}
    engines: {node: '>=18.0.0'}

  '@stellar/stellar-sdk@13.3.0':
    resolution: {integrity: sha512-8+GHcZLp+mdin8gSjcgfb/Lb6sSMYRX6Nf/0LcSJxvjLQR0XHpjGzOiRbYb2jSXo51EnA6kAV5j+4Pzh5OUKUg==}
    engines: {node: '>=18.0.0'}

  '@sveltejs/vite-plugin-svelte-inspector@2.1.0':
    resolution: {integrity: sha512-9QX28IymvBlSCqsCll5t0kQVxipsfhFFL+L2t3nTWfXnddYwxBuAEtTtlaVQpRz9c37BhJjltSeY4AJSC03SSg==}
    engines: {node: ^18.0.0 || >=20}
    peerDependencies:
      '@sveltejs/vite-plugin-svelte': ^3.0.0
      svelte: ^4.0.0 || ^5.0.0-next.0
      vite: ^5.0.0

  '@sveltejs/vite-plugin-svelte@3.1.2':
    resolution: {integrity: sha512-Txsm1tJvtiYeLUVRNqxZGKR/mI+CzuIQuc2gn+YCs9rMTowpNZ2Nqt53JdL8KF9bLhAf2ruR/dr9eZCwdTriRA==}
    engines: {node: ^18.0.0 || >=20}
    peerDependencies:
      svelte: ^4.0.0 || ^5.0.0-next.0
      vite: ^5.0.0

  '@tsconfig/svelte@5.0.4':
    resolution: {integrity: sha512-BV9NplVgLmSi4mwKzD8BD/NQ8erOY/nUE/GpgWe2ckx+wIQF5RyRirn/QsSSCPeulVpc3RA/iJt6DpfTIZps0Q==}

  '@types/estree@1.0.6':
    resolution: {integrity: sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==}

  acorn@8.14.1:
    resolution: {integrity: sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==}
    engines: {node: '>=0.4.0'}
    hasBin: true

  aria-query@5.3.2:
    resolution: {integrity: sha512-COROpnaoap1E2F000S62r6A60uHZnmlvomhfyT2DlTcrY1OrBKn2UhH7qn5wTC9zMvD0AY7csdPSNwKP+7WiQw==}
    engines: {node: '>= 0.4'}

  asynckit@0.4.0:
    resolution: {integrity: sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==}

  axios@1.9.0:
    resolution: {integrity: sha512-re4CqKTJaURpzbLHtIi6XpDv20/CnpXOtjRY5/CU32L8gU8ek9UIivcfvSWvmKEngmVbrUtPpdDwWDWL7DNHvg==}

  axobject-query@4.1.0:
    resolution: {integrity: sha512-qIj0G9wZbMGNLjLmg1PT6v2mE9AH2zlnADJD/2tC6E00hgmhUOfEB6greHPAfLRSufHqROIUTkw6E+M3lH0PTQ==}
    engines: {node: '>= 0.4'}

  bare-addon-resolve@1.9.3:
    resolution: {integrity: sha512-0W343p8kVy9KimDMrxJtJct/ILWL8gzC0Wwg/Fn/GgQplHvrllyz4fPobUVG5+gx9BokWttzg8FYypQP7V5nrA==}
    peerDependencies:
      bare-url: '*'
    peerDependenciesMeta:
      bare-url:
        optional: true

  bare-module-resolve@1.10.2:
    resolution: {integrity: sha512-C9COe/GhWfVXKytW3DElTkiBU+Gb2OXeaVkdGdRB/lp26TVLESHkTGS876iceAGdvtPgohfp9nX8vXHGvN3++Q==}
    peerDependencies:
      bare-url: '*'
    peerDependenciesMeta:
      bare-url:
        optional: true

  bare-os@3.6.0:
    resolution: {integrity: sha512-BUrFS5TqSBdA0LwHop4OjPJwisqxGy6JsWVqV6qaFoe965qqtaKfDzHY5T2YA1gUL0ZeeQeA+4BBc1FJTcHiPw==}
    engines: {bare: '>=1.14.0'}

  bare-path@3.0.0:
    resolution: {integrity: sha512-tyfW2cQcB5NN8Saijrhqn0Zh7AnFNsnczRcuWODH0eYAXBsJ5gVxAUuNr7tsHSC6IZ77cA0SitzT+s47kot8Mw==}

  bare-semver@1.0.1:
    resolution: {integrity: sha512-UtggzHLiTrmFOC/ogQ+Hy7VfoKoIwrP1UFcYtTxoCUdLtsIErT8+SWtOC2DH/snT9h+xDrcBEPcwKei1mzemgg==}

  bare-url@2.1.3:
    resolution: {integrity: sha512-c02+eKvn/4esh5E2lSYQFwHL1WoTIL3u3NeFqb9e7ahBVENXw13MWx4/4/wdPyI557GqqB2Cm0bBbOXD0I0qgA==}

  base32.js@0.1.0:
    resolution: {integrity: sha512-n3TkB02ixgBOhTvANakDb4xaMXnYUVkNoRFJjQflcqMQhyEKxEHdj3E6N8t8sUQ0mjH/3/JxzlXuz3ul/J90pQ==}
    engines: {node: '>=0.12.0'}

  base64-js@1.5.1:
    resolution: {integrity: sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==}

  base64url@3.0.1:
    resolution: {integrity: sha512-ir1UPr3dkwexU7FdV8qBBbNDRUhMmIekYMFZfi+C/sLNnRESKPl23nB9b2pltqfOQNnGzsDdId90AEtG5tCx4A==}
    engines: {node: '>=6.0.0'}

  bignumber.js@9.3.0:
    resolution: {integrity: sha512-EM7aMFTXbptt/wZdMlBv2t8IViwQL+h6SLHosp8Yf0dqJMTnY6iL32opnAB6kAdL0SZPuvcAzFr31o0c/R3/RA==}

  buffer@6.0.3:
    resolution: {integrity: sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==}

  call-bind-apply-helpers@1.0.2:
    resolution: {integrity: sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==}
    engines: {node: '>= 0.4'}

  chokidar@4.0.3:
    resolution: {integrity: sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==}
    engines: {node: '>= 14.16.0'}

  code-red@1.0.4:
    resolution: {integrity: sha512-7qJWqItLA8/VPVlKJlFXU+NBlo/qyfs39aJcuMT/2ere32ZqvF5OSxgdM5xOfJJ7O429gg2HM47y8v9P+9wrNw==}

  combined-stream@1.0.8:
    resolution: {integrity: sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==}
    engines: {node: '>= 0.8'}

  css-tree@2.3.1:
    resolution: {integrity: sha512-6Fv1DV/TYw//QF5IzQdqsNDjx/wc8TrMBZsqjL9eW01tWb7R7k/mq+/VXfJCl7SoD5emsJop9cOByJZfs8hYIw==}
    engines: {node: ^10 || ^12.20.0 || ^14.13.0 || >=15.0.0}

  debug@4.4.0:
    resolution: {integrity: sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==}
    engines: {node: '>=6.0'}
    peerDependencies:
      supports-color: '*'
    peerDependenciesMeta:
      supports-color:
        optional: true

  deepmerge@4.3.1:
    resolution: {integrity: sha512-3sUqbMEc77XqpdNO7FRyRog+eW3ph+GYCbj+rK+uYyRMuwsVy0rMiVtPn+QJlKFvWP/1PYpapqYn0Me2knFn+A==}
    engines: {node: '>=0.10.0'}

  delayed-stream@1.0.0:
    resolution: {integrity: sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==}
    engines: {node: '>=0.4.0'}

  dunder-proto@1.0.1:
    resolution: {integrity: sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==}
    engines: {node: '>= 0.4'}

  es-define-property@1.0.1:
    resolution: {integrity: sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==}
    engines: {node: '>= 0.4'}

  es-errors@1.3.0:
    resolution: {integrity: sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==}
    engines: {node: '>= 0.4'}

  es-object-atoms@1.1.1:
    resolution: {integrity: sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==}
    engines: {node: '>= 0.4'}

  es-set-tostringtag@2.1.0:
    resolution: {integrity: sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==}
    engines: {node: '>= 0.4'}

  esbuild@0.21.5:
    resolution: {integrity: sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==}
    engines: {node: '>=12'}
    hasBin: true

  estree-walker@3.0.3:
    resolution: {integrity: sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==}

  eventsource@2.0.2:
    resolution: {integrity: sha512-IzUmBGPR3+oUG9dUeXynyNmf91/3zUSJg1lCktzKw47OXuhco54U3r9B7O4XX+Rb1Itm9OZ2b0RkTs10bICOxA==}
    engines: {node: '>=12.0.0'}

  fdir@6.4.3:
    resolution: {integrity: sha512-PMXmW2y1hDDfTSRc9gaXIuCCRpuoz3Kaz8cUelp3smouvfT632ozg2vrT6lJsHKKOF59YLbOGfAWGUcKEfRMQw==}
    peerDependencies:
      picomatch: ^3 || ^4
    peerDependenciesMeta:
      picomatch:
        optional: true

  feaxios@0.0.23:
    resolution: {integrity: sha512-eghR0A21fvbkcQBgZuMfQhrXxJzC0GNUGC9fXhBge33D+mFDTwl0aJ35zoQQn575BhyjQitRc5N4f+L4cP708g==}

  follow-redirects@1.15.9:
    resolution: {integrity: sha512-gew4GsXizNgdoRyqmyfMHyAmXsZDk6mHkSxZFCzW9gwlbtOW44CDtYavM+y+72qD/Vq2l550kMF52DT8fOLJqQ==}
    engines: {node: '>=4.0'}
    peerDependencies:
      debug: '*'
    peerDependenciesMeta:
      debug:
        optional: true

  form-data@4.0.2:
    resolution: {integrity: sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==}
    engines: {node: '>= 6'}

  fsevents@2.3.3:
    resolution: {integrity: sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==}
    engines: {node: ^8.16.0 || ^10.6.0 || >=11.0.0}
    os: [darwin]

  function-bind@1.1.2:
    resolution: {integrity: sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==}

  get-intrinsic@1.3.0:
    resolution: {integrity: sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==}
    engines: {node: '>= 0.4'}

  get-proto@1.0.1:
    resolution: {integrity: sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==}
    engines: {node: '>= 0.4'}

  gopd@1.2.0:
    resolution: {integrity: sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==}
    engines: {node: '>= 0.4'}

  has-symbols@1.1.0:
    resolution: {integrity: sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==}
    engines: {node: '>= 0.4'}

  has-tostringtag@1.0.2:
    resolution: {integrity: sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==}
    engines: {node: '>= 0.4'}

  hasown@2.0.2:
    resolution: {integrity: sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==}
    engines: {node: '>= 0.4'}

  ieee754@1.2.1:
    resolution: {integrity: sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==}

  inherits@2.0.4:
    resolution: {integrity: sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==}

  is-reference@3.0.3:
    resolution: {integrity: sha512-ixkJoqQvAP88E6wLydLGGqCJsrFUnqoH6HnaczB8XmDH1oaWU+xxdptvikTgaEhtZ53Ky6YXiBuUI2WXLMCwjw==}

  is-retry-allowed@3.0.0:
    resolution: {integrity: sha512-9xH0xvoggby+u0uGF7cZXdrutWiBiaFG8ZT4YFPXL8NzkyAwX3AKGLeFQLvzDpM430+nDFBZ1LHkie/8ocL06A==}
    engines: {node: '>=12'}

  kleur@4.1.5:
    resolution: {integrity: sha512-o+NO+8WrRiQEE4/7nwRJhN1HWpVmJm511pBHUxPLtp0BUISzlBplORYSmTclCnJvQq2tKu/sgl3xVpkc7ZWuQQ==}
    engines: {node: '>=6'}

  locate-character@3.0.0:
    resolution: {integrity: sha512-SW13ws7BjaeJ6p7Q6CO2nchbYEc3X3J6WrmTTDto7yMPqVSZTUyY5Tjbid+Ab8gLnATtygYtiDIJGQRRn2ZOiA==}

  magic-string@0.30.17:
    resolution: {integrity: sha512-sNPKHvyjVf7gyjwS4xGTaW/mCnF8wnjtifKBEhxfZ7E/S8tQ0rssrwGNn6q8JH/ohItJfSQp9mBtQYuTlH5QnA==}

  math-intrinsics@1.1.0:
    resolution: {integrity: sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==}
    engines: {node: '>= 0.4'}

  mdn-data@2.0.30:
    resolution: {integrity: sha512-GaqWWShW4kv/G9IEucWScBx9G1/vsFZZJUO+tD26M8J8z3Kw5RDQjaoZe03YAClgeS/SWPOcb4nkFBTEi5DUEA==}

  mime-db@1.52.0:
    resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
    engines: {node: '>= 0.6'}

  mime-types@2.1.35:
    resolution: {integrity: sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==}
    engines: {node: '>= 0.6'}

  mri@1.2.0:
    resolution: {integrity: sha512-tzzskb3bG8LvYGFF/mDTpq3jpI6Q9wc3LEmBaghu+DdCssd1FakN7Bc0hVNmEyGq1bq3RgfkCb3cmQLpNPOroA==}
    engines: {node: '>=4'}

  ms@2.1.3:
    resolution: {integrity: sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==}

  nanoid@3.3.10:
    resolution: {integrity: sha512-vSJJTG+t/dIKAUhUDw/dLdZ9s//5OxcHqLaDWWrW4Cdq7o6tdLIczUkMXt2MBNmk6sJRZBZRXVixs7URY1CmIg==}
    engines: {node: ^10 || ^12 || ^13.7 || ^14 || >=15.0.1}
    hasBin: true

  periscopic@3.1.0:
    resolution: {integrity: sha512-vKiQ8RRtkl9P+r/+oefh25C3fhybptkHKCZSPlcXiJux2tJF55GnEj3BVn4A5gKfq9NWWXXrxkHBwVPUfH0opw==}

  picocolors@1.1.1:
    resolution: {integrity: sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==}

  postcss@8.5.3:
    resolution: {integrity: sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A==}
    engines: {node: ^10 || ^12 || >=14}

  proxy-from-env@1.1.0:
    resolution: {integrity: sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==}

  randombytes@2.1.0:
    resolution: {integrity: sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==}

  readdirp@4.1.2:
    resolution: {integrity: sha512-GDhwkLfywWL2s6vEjyhri+eXmfH6j1L7JE27WhqLeYzoh/A3DBaYGEj2H/HFZCn/kMfim73FXxEJTw06WtxQwg==}
    engines: {node: '>= 14.18.0'}

  require-addon@1.1.0:
    resolution: {integrity: sha512-KbXAD5q2+v1GJnkzd8zzbOxchTkStSyJZ9QwoCq3QwEXAaIlG3wDYRZGzVD357jmwaGY7hr5VaoEAL0BkF0Kvg==}
    engines: {bare: '>=1.10.0'}

  rollup@4.36.0:
    resolution: {integrity: sha512-zwATAXNQxUcd40zgtQG0ZafcRK4g004WtEl7kbuhTWPvf07PsfohXl39jVUvPF7jvNAIkKPQ2XrsDlWuxBd++Q==}
    engines: {node: '>=18.0.0', npm: '>=8.0.0'}
    hasBin: true

  sade@1.8.1:
    resolution: {integrity: sha512-xal3CZX1Xlo/k4ApwCFrHVACi9fBqJ7V+mwhBsuf/1IOKbBy098Fex+Wa/5QMubw09pSZ/u8EY8PWgevJsXp1A==}
    engines: {node: '>=6'}

  safe-buffer@5.2.1:
    resolution: {integrity: sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==}

  sha.js@2.4.11:
    resolution: {integrity: sha512-QMEp5B7cftE7APOjk5Y6xgrbWu+WkLVQwk8JNjZ8nKRciZaByEW6MubieAiToS7+dwvrjGhH8jRXz3MVd0AYqQ==}
    hasBin: true

  sodium-native@4.3.3:
    resolution: {integrity: sha512-OnxSlN3uyY8D0EsLHpmm2HOFmKddQVvEMmsakCrXUzSd8kjjbzL413t4ZNF3n0UxSwNgwTyUvkmZHTfuCeiYSw==}

  source-map-js@1.2.1:
    resolution: {integrity: sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==}
    engines: {node: '>=0.10.0'}

  svelte-check@4.1.7:
    resolution: {integrity: sha512-1jX4BzXrQJhC/Jt3SqYf6Ntu//vmfc6VWp07JkRfK2nn+22yIblspVUo96gzMkg0Zov8lQicxhxsMzOctwcMQQ==}
    engines: {node: '>= 18.0.0'}
    hasBin: true
    peerDependencies:
      svelte: ^4.0.0 || ^5.0.0-next.0
      typescript: '>=5.0.0'

  svelte-hmr@0.16.0:
    resolution: {integrity: sha512-Gyc7cOS3VJzLlfj7wKS0ZnzDVdv3Pn2IuVeJPk9m2skfhcu5bq3wtIZyQGggr7/Iim5rH5cncyQft/kRLupcnA==}
    engines: {node: ^12.20 || ^14.13.1 || >= 16}
    peerDependencies:
      svelte: ^3.19.0 || ^4.0.0

  svelte@4.2.19:
    resolution: {integrity: sha512-IY1rnGr6izd10B0A8LqsBfmlT5OILVuZ7XsI0vdGPEvuonFV7NYEUK4dAkm9Zg2q0Um92kYjTpS1CAP3Nh/KWw==}
    engines: {node: '>=16'}

  toml@3.0.0:
    resolution: {integrity: sha512-y/mWCZinnvxjTKYhJ+pYxwD0mRLVvOtdS2Awbgxln6iEnt4rk0yBxeSBHkGJcPucRiG0e55mwWp+g/05rsrd6w==}

  tslib@2.8.1:
    resolution: {integrity: sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==}

  tweetnacl@1.0.3:
    resolution: {integrity: sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw==}

  typescript@5.8.3:
    resolution: {integrity: sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==}
    engines: {node: '>=14.17'}
    hasBin: true

  urijs@1.19.11:
    resolution: {integrity: sha512-HXgFDgDommxn5/bIv0cnQZsPhHDA90NPHD6+c/v21U5+Sx5hoP8+dP9IZXBU1gIfvdRfhG8cel9QNPeionfcCQ==}

  vite-plugin-filter-replace@0.1.14:
    resolution: {integrity: sha512-3onEAYgjJQTCJN+/f8+1vOUH3X/tRmXsfxmgH3QtpReGKi+xtP1jMpAEnYsNqw9mI2shZmxFm3LS+n52XczwYQ==}

  vite@5.4.14:
    resolution: {integrity: sha512-EK5cY7Q1D8JNhSaPKVK4pwBFvaTmZxEnoKXLG/U9gmdDcihQGNzFlgIvaxezFR4glP1LsuiedwMBqCXH3wZccA==}
    engines: {node: ^18.0.0 || >=20.0.0}
    hasBin: true
    peerDependencies:
      '@types/node': ^18.0.0 || >=20.0.0
      less: '*'
      lightningcss: ^1.21.0
      sass: '*'
      sass-embedded: '*'
      stylus: '*'
      sugarss: '*'
      terser: ^5.4.0
    peerDependenciesMeta:
      '@types/node':
        optional: true
      less:
        optional: true
      lightningcss:
        optional: true
      sass:
        optional: true
      sass-embedded:
        optional: true
      stylus:
        optional: true
      sugarss:
        optional: true
      terser:
        optional: true

  vitefu@0.2.5:
    resolution: {integrity: sha512-SgHtMLoqaeeGnd2evZ849ZbACbnwQCIwRH57t18FxcXoZop0uQu0uzlIhJBlF/eWVzuce0sHeqPcDo+evVcg8Q==}
    peerDependencies:
      vite: ^3.0.0 || ^4.0.0 || ^5.0.0
    peerDependenciesMeta:
      vite:
        optional: true

snapshots:

  '@ampproject/remapping@2.3.0':
    dependencies:
      '@jridgewell/gen-mapping': 0.3.8
      '@jridgewell/trace-mapping': 0.3.25

  '@esbuild/aix-ppc64@0.21.5':
    optional: true

  '@esbuild/android-arm64@0.21.5':
    optional: true

  '@esbuild/android-arm@0.21.5':
    optional: true

  '@esbuild/android-x64@0.21.5':
    optional: true

  '@esbuild/darwin-arm64@0.21.5':
    optional: true

  '@esbuild/darwin-x64@0.21.5':
    optional: true

  '@esbuild/freebsd-arm64@0.21.5':
    optional: true

  '@esbuild/freebsd-x64@0.21.5':
    optional: true

  '@esbuild/linux-arm64@0.21.5':
    optional: true

  '@esbuild/linux-arm@0.21.5':
    optional: true

  '@esbuild/linux-ia32@0.21.5':
    optional: true

  '@esbuild/linux-loong64@0.21.5':
    optional: true

  '@esbuild/linux-mips64el@0.21.5':
    optional: true

  '@esbuild/linux-ppc64@0.21.5':
    optional: true

  '@esbuild/linux-riscv64@0.21.5':
    optional: true

  '@esbuild/linux-s390x@0.21.5':
    optional: true

  '@esbuild/linux-x64@0.21.5':
    optional: true

  '@esbuild/netbsd-x64@0.21.5':
    optional: true

  '@esbuild/openbsd-x64@0.21.5':
    optional: true

  '@esbuild/sunos-x64@0.21.5':
    optional: true

  '@esbuild/win32-arm64@0.21.5':
    optional: true

  '@esbuild/win32-ia32@0.21.5':
    optional: true

  '@esbuild/win32-x64@0.21.5':
    optional: true

  '@jridgewell/gen-mapping@0.3.8':
    dependencies:
      '@jridgewell/set-array': 1.2.1
      '@jridgewell/sourcemap-codec': 1.5.0
      '@jridgewell/trace-mapping': 0.3.25

  '@jridgewell/resolve-uri@3.1.2': {}

  '@jridgewell/set-array@1.2.1': {}

  '@jridgewell/sourcemap-codec@1.5.0': {}

  '@jridgewell/trace-mapping@0.3.25':
    dependencies:
      '@jridgewell/resolve-uri': 3.1.2
      '@jridgewell/sourcemap-codec': 1.5.0

  '@rollup/rollup-android-arm-eabi@4.36.0':
    optional: true

  '@rollup/rollup-android-arm64@4.36.0':
    optional: true

  '@rollup/rollup-darwin-arm64@4.36.0':
    optional: true

  '@rollup/rollup-darwin-x64@4.36.0':
    optional: true

  '@rollup/rollup-freebsd-arm64@4.36.0':
    optional: true

  '@rollup/rollup-freebsd-x64@4.36.0':
    optional: true

  '@rollup/rollup-linux-arm-gnueabihf@4.36.0':
    optional: true

  '@rollup/rollup-linux-arm-musleabihf@4.36.0':
    optional: true

  '@rollup/rollup-linux-arm64-gnu@4.36.0':
    optional: true

  '@rollup/rollup-linux-arm64-musl@4.36.0':
    optional: true

  '@rollup/rollup-linux-loongarch64-gnu@4.36.0':
    optional: true

  '@rollup/rollup-linux-powerpc64le-gnu@4.36.0':
    optional: true

  '@rollup/rollup-linux-riscv64-gnu@4.36.0':
    optional: true

  '@rollup/rollup-linux-s390x-gnu@4.36.0':
    optional: true

  '@rollup/rollup-linux-x64-gnu@4.36.0':
    optional: true

  '@rollup/rollup-linux-x64-musl@4.36.0':
    optional: true

  '@rollup/rollup-win32-arm64-msvc@4.36.0':
    optional: true

  '@rollup/rollup-win32-ia32-msvc@4.36.0':
    optional: true

  '@rollup/rollup-win32-x64-msvc@4.36.0':
    optional: true

  '@stellar/js-xdr@3.1.2': {}

  '@stellar/stellar-base@13.1.0':
    dependencies:
      '@stellar/js-xdr': 3.1.2
      base32.js: 0.1.0
      bignumber.js: 9.3.0
      buffer: 6.0.3
      sha.js: 2.4.11
      tweetnacl: 1.0.3
    optionalDependencies:
      sodium-native: 4.3.3

  '@stellar/stellar-sdk@13.3.0':
    dependencies:
      '@stellar/stellar-base': 13.1.0
      axios: 1.9.0
      bignumber.js: 9.3.0
      eventsource: 2.0.2
      feaxios: 0.0.23
      randombytes: 2.1.0
      toml: 3.0.0
      urijs: 1.19.11
    transitivePeerDependencies:
      - debug

  '@sveltejs/vite-plugin-svelte-inspector@2.1.0(@sveltejs/vite-plugin-svelte@3.1.2(svelte@4.2.19)(vite@5.4.14))(svelte@4.2.19)(vite@5.4.14)':
    dependencies:
      '@sveltejs/vite-plugin-svelte': 3.1.2(svelte@4.2.19)(vite@5.4.14)
      debug: 4.4.0
      svelte: 4.2.19
      vite: 5.4.14
    transitivePeerDependencies:
      - supports-color

  '@sveltejs/vite-plugin-svelte@3.1.2(svelte@4.2.19)(vite@5.4.14)':
    dependencies:
      '@sveltejs/vite-plugin-svelte-inspector': 2.1.0(@sveltejs/vite-plugin-svelte@3.1.2(svelte@4.2.19)(vite@5.4.14))(svelte@4.2.19)(vite@5.4.14)
      debug: 4.4.0
      deepmerge: 4.3.1
      kleur: 4.1.5
      magic-string: 0.30.17
      svelte: 4.2.19
      svelte-hmr: 0.16.0(svelte@4.2.19)
      vite: 5.4.14
      vitefu: 0.2.5(vite@5.4.14)
    transitivePeerDependencies:
      - supports-color

  '@tsconfig/svelte@5.0.4': {}

  '@types/estree@1.0.6': {}

  acorn@8.14.1: {}

  aria-query@5.3.2: {}

  asynckit@0.4.0: {}

  axios@1.9.0:
    dependencies:
      follow-redirects: 1.15.9
      form-data: 4.0.2
      proxy-from-env: 1.1.0
    transitivePeerDependencies:
      - debug

  axobject-query@4.1.0: {}

  bare-addon-resolve@1.9.3(bare-url@2.1.3):
    dependencies:
      bare-module-resolve: 1.10.2(bare-url@2.1.3)
      bare-semver: 1.0.1
    optionalDependencies:
      bare-url: 2.1.3
    optional: true

  bare-module-resolve@1.10.2(bare-url@2.1.3):
    dependencies:
      bare-semver: 1.0.1
    optionalDependencies:
      bare-url: 2.1.3
    optional: true

  bare-os@3.6.0:
    optional: true

  bare-path@3.0.0:
    dependencies:
      bare-os: 3.6.0
    optional: true

  bare-semver@1.0.1:
    optional: true

  bare-url@2.1.3:
    dependencies:
      bare-path: 3.0.0
    optional: true

  base32.js@0.1.0: {}

  base64-js@1.5.1: {}

  base64url@3.0.1: {}

  bignumber.js@9.3.0: {}

  buffer@6.0.3:
    dependencies:
      base64-js: 1.5.1
      ieee754: 1.2.1

  call-bind-apply-helpers@1.0.2:
    dependencies:
      es-errors: 1.3.0
      function-bind: 1.1.2

  chokidar@4.0.3:
    dependencies:
      readdirp: 4.1.2

  code-red@1.0.4:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.0
      '@types/estree': 1.0.6
      acorn: 8.14.1
      estree-walker: 3.0.3
      periscopic: 3.1.0

  combined-stream@1.0.8:
    dependencies:
      delayed-stream: 1.0.0

  css-tree@2.3.1:
    dependencies:
      mdn-data: 2.0.30
      source-map-js: 1.2.1

  debug@4.4.0:
    dependencies:
      ms: 2.1.3

  deepmerge@4.3.1: {}

  delayed-stream@1.0.0: {}

  dunder-proto@1.0.1:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-errors: 1.3.0
      gopd: 1.2.0

  es-define-property@1.0.1: {}

  es-errors@1.3.0: {}

  es-object-atoms@1.1.1:
    dependencies:
      es-errors: 1.3.0

  es-set-tostringtag@2.1.0:
    dependencies:
      es-errors: 1.3.0
      get-intrinsic: 1.3.0
      has-tostringtag: 1.0.2
      hasown: 2.0.2

  esbuild@0.21.5:
    optionalDependencies:
      '@esbuild/aix-ppc64': 0.21.5
      '@esbuild/android-arm': 0.21.5
      '@esbuild/android-arm64': 0.21.5
      '@esbuild/android-x64': 0.21.5
      '@esbuild/darwin-arm64': 0.21.5
      '@esbuild/darwin-x64': 0.21.5
      '@esbuild/freebsd-arm64': 0.21.5
      '@esbuild/freebsd-x64': 0.21.5
      '@esbuild/linux-arm': 0.21.5
      '@esbuild/linux-arm64': 0.21.5
      '@esbuild/linux-ia32': 0.21.5
      '@esbuild/linux-loong64': 0.21.5
      '@esbuild/linux-mips64el': 0.21.5
      '@esbuild/linux-ppc64': 0.21.5
      '@esbuild/linux-riscv64': 0.21.5
      '@esbuild/linux-s390x': 0.21.5
      '@esbuild/linux-x64': 0.21.5
      '@esbuild/netbsd-x64': 0.21.5
      '@esbuild/openbsd-x64': 0.21.5
      '@esbuild/sunos-x64': 0.21.5
      '@esbuild/win32-arm64': 0.21.5
      '@esbuild/win32-ia32': 0.21.5
      '@esbuild/win32-x64': 0.21.5

  estree-walker@3.0.3:
    dependencies:
      '@types/estree': 1.0.6

  eventsource@2.0.2: {}

  fdir@6.4.3: {}

  feaxios@0.0.23:
    dependencies:
      is-retry-allowed: 3.0.0

  follow-redirects@1.15.9: {}

  form-data@4.0.2:
    dependencies:
      asynckit: 0.4.0
      combined-stream: 1.0.8
      es-set-tostringtag: 2.1.0
      mime-types: 2.1.35

  fsevents@2.3.3:
    optional: true

  function-bind@1.1.2: {}

  get-intrinsic@1.3.0:
    dependencies:
      call-bind-apply-helpers: 1.0.2
      es-define-property: 1.0.1
      es-errors: 1.3.0
      es-object-atoms: 1.1.1
      function-bind: 1.1.2
      get-proto: 1.0.1
      gopd: 1.2.0
      has-symbols: 1.1.0
      hasown: 2.0.2
      math-intrinsics: 1.1.0

  get-proto@1.0.1:
    dependencies:
      dunder-proto: 1.0.1
      es-object-atoms: 1.1.1

  gopd@1.2.0: {}

  has-symbols@1.1.0: {}

  has-tostringtag@1.0.2:
    dependencies:
      has-symbols: 1.1.0

  hasown@2.0.2:
    dependencies:
      function-bind: 1.1.2

  ieee754@1.2.1: {}

  inherits@2.0.4: {}

  is-reference@3.0.3:
    dependencies:
      '@types/estree': 1.0.6

  is-retry-allowed@3.0.0: {}

  kleur@4.1.5: {}

  locate-character@3.0.0: {}

  magic-string@0.30.17:
    dependencies:
      '@jridgewell/sourcemap-codec': 1.5.0

  math-intrinsics@1.1.0: {}

  mdn-data@2.0.30: {}

  mime-db@1.52.0: {}

  mime-types@2.1.35:
    dependencies:
      mime-db: 1.52.0

  mri@1.2.0: {}

  ms@2.1.3: {}

  nanoid@3.3.10: {}

  periscopic@3.1.0:
    dependencies:
      '@types/estree': 1.0.6
      estree-walker: 3.0.3
      is-reference: 3.0.3

  picocolors@1.1.1: {}

  postcss@8.5.3:
    dependencies:
      nanoid: 3.3.10
      picocolors: 1.1.1
      source-map-js: 1.2.1

  proxy-from-env@1.1.0: {}

  randombytes@2.1.0:
    dependencies:
      safe-buffer: 5.2.1

  readdirp@4.1.2: {}

  require-addon@1.1.0:
    dependencies:
      bare-addon-resolve: 1.9.3(bare-url@2.1.3)
      bare-url: 2.1.3
    optional: true

  rollup@4.36.0:
    dependencies:
      '@types/estree': 1.0.6
    optionalDependencies:
      '@rollup/rollup-android-arm-eabi': 4.36.0
      '@rollup/rollup-android-arm64': 4.36.0
      '@rollup/rollup-darwin-arm64': 4.36.0
      '@rollup/rollup-darwin-x64': 4.36.0
      '@rollup/rollup-freebsd-arm64': 4.36.0
      '@rollup/rollup-freebsd-x64': 4.36.0
      '@rollup/rollup-linux-arm-gnueabihf': 4.36.0
      '@rollup/rollup-linux-arm-musleabihf': 4.36.0
      '@rollup/rollup-linux-arm64-gnu': 4.36.0
      '@rollup/rollup-linux-arm64-musl': 4.36.0
      '@rollup/rollup-linux-loongarch64-gnu': 4.36.0
      '@rollup/rollup-linux-powerpc64le-gnu': 4.36.0
      '@rollup/rollup-linux-riscv64-gnu': 4.36.0
      '@rollup/rollup-linux-s390x-gnu': 4.36.0
      '@rollup/rollup-linux-x64-gnu': 4.36.0
      '@rollup/rollup-linux-x64-musl': 4.36.0
      '@rollup/rollup-win32-arm64-msvc': 4.36.0
      '@rollup/rollup-win32-ia32-msvc': 4.36.0
      '@rollup/rollup-win32-x64-msvc': 4.36.0
      fsevents: 2.3.3

  sade@1.8.1:
    dependencies:
      mri: 1.2.0

  safe-buffer@5.2.1: {}

  sha.js@2.4.11:
    dependencies:
      inherits: 2.0.4
      safe-buffer: 5.2.1

  sodium-native@4.3.3:
    dependencies:
      require-addon: 1.1.0
    optional: true

  source-map-js@1.2.1: {}

  svelte-check@4.1.7(svelte@4.2.19)(typescript@5.8.3):
    dependencies:
      '@jridgewell/trace-mapping': 0.3.25
      chokidar: 4.0.3
      fdir: 6.4.3
      picocolors: 1.1.1
      sade: 1.8.1
      svelte: 4.2.19
      typescript: 5.8.3
    transitivePeerDependencies:
      - picomatch

  svelte-hmr@0.16.0(svelte@4.2.19):
    dependencies:
      svelte: 4.2.19

  svelte@4.2.19:
    dependencies:
      '@ampproject/remapping': 2.3.0
      '@jridgewell/sourcemap-codec': 1.5.0
      '@jridgewell/trace-mapping': 0.3.25
      '@types/estree': 1.0.6
      acorn: 8.14.1
      aria-query: 5.3.2
      axobject-query: 4.1.0
      code-red: 1.0.4
      css-tree: 2.3.1
      estree-walker: 3.0.3
      is-reference: 3.0.3
      locate-character: 3.0.0
      magic-string: 0.30.17
      periscopic: 3.1.0

  toml@3.0.0: {}

  tslib@2.8.1: {}

  tweetnacl@1.0.3: {}

  typescript@5.8.3: {}

  urijs@1.19.11: {}

  vite-plugin-filter-replace@0.1.14:
    dependencies:
      magic-string: 0.30.17

  vite@5.4.14:
    dependencies:
      esbuild: 0.21.5
      postcss: 8.5.3
      rollup: 4.36.0
    optionalDependencies:
      fsevents: 2.3.3

  vitefu@0.2.5(vite@5.4.14):
    optionalDependencies:
      vite: 5.4.14



================================================
FILE: demo/pnpm-workspace.yaml
================================================
[Empty file]


================================================
FILE: demo/svelte.config.js
================================================
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

export default {
  // Consult https://svelte.dev/docs#compile-time-svelte-preprocess
  // for more information about preprocessors
  preprocess: vitePreprocess(),
}



================================================
FILE: demo/tsconfig.json
================================================
{
  "extends": "@tsconfig/svelte/tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "resolveJsonModule": true,
    "isolatedModules": true,
  },
  "include": ["src/**/*.ts", "src/**/*.svelte"],
  "references": [{ "path": "./tsconfig.node.json" }]
}



================================================
FILE: demo/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true
  },
  "include": ["vite.config.ts"]
}



================================================
FILE: demo/vite.config.ts
================================================
import { defineConfig } from 'vite'
import { svelte } from '@sveltejs/vite-plugin-svelte'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [svelte()],
  build: {
    target: "ESNext"
  },
})



================================================
FILE: demo/.env.example
================================================
VITE_walletWasmHash="ecd990f0b45ca6817149b6175f79b32efb442f35731985a084131e8265c4cd90"
VITE_nativeContractId="CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC"
VITE_networkPassphrase="Test SDF Network ; September 2015"
VITE_rpcUrl="https://soroban-testnet.stellar.org"
VITE_launchtubeUrl="https://testnet.launchtube.xyz"
VITE_launchtubeJwt="???"
VITE_mercuryProjectName="smart-wallets-next-dima"
VITE_mercuryUrl="https://api.mercurydata.app"
VITE_mercuryJwt="???"
# or VITE_mercuryKey="???"


================================================
FILE: demo/src/app.css
================================================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}


================================================
FILE: demo/src/App.svelte
================================================
<script lang="ts">
	import base64url from "base64url";
	import { Buffer } from "buffer";
	import {
		account,
		fundPubkey,
		fundSigner,
		native,
		server,
	} from "./lib/common";
	import { Keypair } from "@stellar/stellar-sdk/minimal";
    import { SignerStore, SignerKey, type SignerLimits, type Signer } from "passkey-kit";

	// TODO need to support two toggles:
	// - between temp and persistent
	// - and admin, basic and policy
	// - full visual support for admin, basic and policy keys

	const ADMIN_KEY = "AAAAEAAAAAEAAAABAAAAAQ=="; // TODO very rough until we're actually parsing the limits object
	const NATIVE_SAC =
		"CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC";
	const SAMPLE_POLICY =
		"CBJQC7FVOAJTBMOOSRUTAED3JVHGNHPKSKPXSREOWFHL7O6LW2ATQZAU";
	const SECRET = "SBEIDWQVWNLPCP35EYQ6GLWKFQ2MDY7APRLOQ3AJNU6KSE7FXGA7C55W";
	const PUBLIC = "GBVQMKYWGELU6IKLK2U6EIIHTNW5LIUYJE7FUQPG4FAB3QQ3KAINFVYS";

	let keyId: string;
	let contractId: string;
	let adminSigner: string | undefined;
	let balance: string;
	let signers: Signer[] = [];

	let keyName: string = "";
	// let keyAdmin: boolean = false;

	if (localStorage.hasOwnProperty("sp:keyId")) {
		keyId = localStorage.getItem("sp:keyId")!;
		connect(keyId);
	}

	async function register() {
		const user = prompt("Give this passkey a name");

		if (!user) return;

		try {
			const {
				keyId: kid,
				contractId: cid,
				signedTx,
			} = await account.createWallet("Super Peach", user);
			
			const res = await server.send(signedTx);

			console.log(res);

			keyId = base64url(kid);
			localStorage.setItem("sp:keyId", keyId);

			contractId = cid;
			console.log("register", cid);

			await getWalletSigners();
			await fundWallet();
		} catch (err: any) {
			console.error(err);
			alert(err.message);
		}
	}
	async function connect(keyId_?: string) {
		try {
			const { keyId: kid, contractId: cid } = await account.connectWallet(
				{
					keyId: keyId_,
					getContractId: (keyId) => server.getContractId({ keyId }),
				},
			);

			keyId = base64url(kid);
			localStorage.setItem("sp:keyId", keyId);

			contractId = cid;
			console.log("connect", cid);

			await getWalletBalance();
			await getWalletSigners();
		} catch (err: any) {
			console.error(err);
			// alert(err.message)
		}
	}
	async function reset() {
		localStorage.removeItem("sp:keyId");
		location.reload();
	}

	async function addSigner(publicKey?: string) {
		try {
			let id: Buffer;
			let pk: Buffer;

			if (publicKey && keyId) {
				id = base64url.toBuffer(keyId);
				pk = base64url.toBuffer(publicKey);
				// keyAdmin = false;
			} else {
				if (!keyName) return;

				const { keyId: kid, publicKey } = await account.createKey(
					"Super Peach",
					keyName,
				);

				id = kid;
				pk = publicKey;
			}

			const { sequence } = await account.rpc.getLatestLedger()
			const at = await account.addSecp256r1(id, pk, undefined, SignerStore.Temporary, sequence + 518_400);

			await account.sign(at, { keyId: adminSigner });
			const res = await server.send(at.built!);

			console.log(res);

			await getWalletSigners();

			keyName = "";
			// keyAdmin = false;
		} catch (err: any) {
			console.error(err);
			alert(err.message);
		}
	}
	async function addEd25519Signer() {
		const pubkey = PUBLIC; // prompt('Enter public key');

		if (pubkey) {
			const signer_limits = undefined;

			// const signer_limits: SignerLimits = new Map();
			// const signer_keys: SignerKey[] = [];

			// signer_keys.push(SignerKey.Policy(SAMPLE_POLICY));

			// signer_limits.set(NATIVE_SAC, signer_keys);

			const at = await account.addEd25519(pubkey, signer_limits, SignerStore.Temporary);

			await account.sign(at, { keyId: adminSigner });
			const res = await server.send(at.built!);

			console.log(res);

			await getWalletSigners();
		}
	}
	async function addPolicySigner() {
		const signer_limits: SignerLimits = new Map();
		const signer_keys: SignerKey[] = [];

		signer_keys.push(SignerKey.Ed25519(PUBLIC));

		signer_limits.set(NATIVE_SAC, signer_keys);

		const at = await account.addPolicy(SAMPLE_POLICY, signer_limits, SignerStore.Temporary);

		await account.sign(at, { keyId: adminSigner });
		const res = await server.send(at.built!);

		console.log(res);

		await getWalletSigners();
	}
	async function removeSigner(signer: string, type: string) {
		try {
			let key: SignerKey;

			switch (type) {
				case "Policy":
					key = SignerKey.Policy(signer);
					break;
				case "Ed25519":
					key = SignerKey.Ed25519(signer);
					break;
				case "Secp256r1":
					key = SignerKey.Secp256r1(signer);
					break;
				default:
					throw new Error("Invalid signer type");
			}

			const at = await account.remove(key);

			await account.sign(at, { keyId: adminSigner });
			const res = await server.send(at.built!);

			console.log(res);

			await getWalletSigners();
		} catch (err: any) {
			console.error(err);
			alert(err.message);
		}
	}
	async function fundWallet() {
		const { built, ...transfer } = await native.transfer({
			to: contractId,
			from: fundPubkey,
			amount: BigInt(100 * 10_000_000),
		});

		await transfer.signAuthEntries({
			address: fundPubkey,
			signAuthEntry: fundSigner.signAuthEntry,
		});

		const res = await server.send(built!);

		console.log(res);

		await getWalletBalance();
	}

	////
	async function multisigTransfer() {
		const keypair = Keypair.fromSecret(SECRET);

		const at = await native.transfer({
			to: fundPubkey,
			from: contractId,
			amount: BigInt(10_000_000),
		});

		await account.sign(at, { keyId: adminSigner });
		await account.sign(at, { keypair });
		await account.sign(at, { policy: SAMPLE_POLICY });

		console.log(at.built!.toXDR());

		const res = await server.send(at);

		console.log(res);

		await getWalletBalance();
	}
	////

	async function ed25519Transfer() {
		const secret = SECRET; // prompt('Enter secret key');

		if (secret) {
			const keypair = Keypair.fromSecret(secret);
			const at = await native.transfer({
				to: fundPubkey,
				from: contractId,
				amount: BigInt(10_000_000),
			});

			await account.sign(at, { keypair });

			// NOTE won't work if the ed25519 signer has a policy signer_key restriction
			// If you want this to work you need to remove the policy restriction from the ed25519 signer first
			// (though that will make the policy transfer less interesting)
			const res = await server.send(at.built!);

			console.log(res);

			await getWalletBalance();
		}
	}

	////
	async function policyTransfer() {
		const keypair = Keypair.fromSecret(SECRET);

		let at = await native.transfer({
			to: fundPubkey,
			from: contractId,
			amount: BigInt(10_000_000),
		});

		await account.sign(at, { keypair });
		await account.sign(at, { policy: SAMPLE_POLICY });

		console.log(at.built!.toXDR());

		const res = await server.send(at.built!);

		console.log(res);

		await getWalletBalance();
	}
	////

	async function walletTransfer(signer: string, kind: string) {
		if (kind === "Policy") {
			return policyTransfer();
		} else if (kind === "Ed25519") {
			return ed25519Transfer();
		}

		const at = await native.transfer({
			to: fundPubkey,
			from: contractId,
			amount: BigInt(10_000_000),
		});

		await account.sign(at, { keyId: signer });
		const res = await server.send(at.built!);

		console.log(res);

		await getWalletBalance();
	}
	async function getWalletBalance() {
		const { result } = await native.balance({ id: contractId });

		balance = result.toString();
		console.log(balance);
	}
	async function getWalletSigners() {
		signers = await server.getSigners(contractId);
		console.log(signers);

		const adminKeys = signers.filter(({ limits }) => limits === ADMIN_KEY);

		adminSigner = (
			adminKeys.find(({ key }) => keyId === key) || adminKeys[0]
		).key;
	}
</script>

<main>
	<button on:click={register}>Register</button>
	<button on:click={() => connect()}>Sign In</button>
	<button on:click={reset}>Reset</button>

	{#if contractId}
		<p>{contractId}</p>

		{#if balance}
			<p>{parseFloat((Number(balance) / 10_000_000).toFixed(7))} XLM</p>
		{/if}

		<button on:click={fundWallet}>Add Funds</button>
		<button on:click={getWalletBalance}>Get Balance</button>
		<br />
		<button on:click={addEd25519Signer}>Add Ed25519 Signer</button>
		<button on:click={ed25519Transfer}>Ed25519 Transfer</button>
		<br />
		<button on:click={addPolicySigner}>Add Policy Signer</button>
		<button on:click={policyTransfer}>Policy Transfer</button>
		<br />
		<button on:click={multisigTransfer}>Multisig Transfer</button>

		<form on:submit|preventDefault>
			<ul style="list-style: none; padding: 0;">
				<li>
					<input
						type="text"
						placeholder="Signer name"
						bind:value={keyName}
					/>
				</li>
				<!-- <li>
					<label for="admin">Make admin?</label>
					<input
						type="checkbox"
						id="admin"
						name="admin"
						bind:checked={keyAdmin}
					/>
				</li> -->
				<li>
					<button on:click={() => addSigner()}>Add Signer</button>
				</li>
			</ul>
		</form>
	{/if}

	<ul>
		{#each signers as { kind, key, val, expiration, limits, evicted }}
			<li>
				<button disabled>
					{#if adminSigner === key}
						{#if keyId === key}◉{:else}◎{/if}&nbsp;
					{:else if keyId === key}
						●&nbsp;
					{/if}
					{#if limits === ADMIN_KEY}
						ADMIN
					{:else}
						SESSION
					{/if}
				</button>

				{key}

				<button on:click={() => walletTransfer(key, kind)}
					>Transfer 1 XLM</button
				>

				<!-- TODO rethink {#if (limits !== ADMIN_KEY || admins > 1) && key !== keyId} -->
				<button on:click={() => removeSigner(key, kind)}>Remove</button>
				<!-- {/if} -->

				<!-- TODO redo {#if limits === ADMIN_KEY && key !== adminSigner}
					<button on:click={() => (adminSigner = key)}
						>Set Active Admin</button
					>
				{:else if expired && key === account.keyId}
					<button on:click={() => addSigner(val)}>Reload</button>
				{/if} -->
			</li>
		{/each}
	</ul>

	<!-- {#if contractId}
		<iframe
			src="https://stellar.expert/explorer/testnet/contract/{contractId}"
			frameborder="0"
			width="1000"
			height="600"
		></iframe>
	{/if} -->
</main>



================================================
FILE: demo/src/main.ts
================================================
import './app.css'
import App from './App.svelte'

const app = new App({
  target: document.getElementById('app')!,
})

export default app



================================================
FILE: demo/src/vite-env.d.ts
================================================
/// <reference types="svelte" />
/// <reference types="vite/client" />

interface ImportMetaEnv {
    readonly VITE_walletWasmHash: string;
    readonly VITE_networkPassphrase: string;
    readonly VITE_nativeContractId: string;
    readonly VITE_rpcUrl: string;
    readonly VITE_launchtubeUrl: string;
    readonly VITE_launchtubeJwt: string;
    readonly VITE_mercuryProjectName: string;
    readonly VITE_mercuryUrl: string;
    readonly VITE_mercuryJwt: string;
    readonly VITE_mercuryKey: string;
}

interface ImportMeta {
    readonly env: ImportMetaEnv;
}


================================================
FILE: demo/src/lib/common.ts
================================================
import { PasskeyKit, PasskeyServer, SACClient } from "passkey-kit";
import { Account, Keypair, StrKey } from "@stellar/stellar-sdk/minimal"
import { Buffer } from "buffer";
import { basicNodeSigner } from "@stellar/stellar-sdk/minimal/contract";
import { Server } from "@stellar/stellar-sdk/minimal/rpc";

export const rpc = new Server(import.meta.env.VITE_rpcUrl);

export const mockPubkey = StrKey.encodeEd25519PublicKey(Buffer.alloc(32))
export const mockSource = new Account(mockPubkey, '0')

export const fundKeypair = new Promise<Keypair>(async (resolve) => {
    const now = new Date();

    now.setMinutes(0, 0, 0);

    const nowData = new TextEncoder().encode(now.getTime().toString());
    const hashBuffer = await crypto.subtle.digest('SHA-256', nowData);
    const keypair = Keypair.fromRawEd25519Seed(Buffer.from(hashBuffer))
    const publicKey = keypair.publicKey()

    rpc.getAccount(publicKey)
        .catch(() => rpc.requestAirdrop(publicKey))
        .catch(() => { })

    resolve(keypair)
})
export const fundPubkey = (await fundKeypair).publicKey()
export const fundSigner = basicNodeSigner(await fundKeypair, import.meta.env.VITE_networkPassphrase)

export const account = new PasskeyKit({
    rpcUrl: import.meta.env.VITE_rpcUrl,
    networkPassphrase: import.meta.env.VITE_networkPassphrase,
    walletWasmHash: import.meta.env.VITE_walletWasmHash,
});
export const server = new PasskeyServer({
    rpcUrl: import.meta.env.VITE_rpcUrl,
    launchtubeUrl: import.meta.env.VITE_launchtubeUrl,
    launchtubeJwt: import.meta.env.VITE_launchtubeJwt,
    mercuryProjectName: import.meta.env.VITE_mercuryProjectName,
    mercuryUrl: import.meta.env.VITE_mercuryUrl,
    mercuryJwt: import.meta.env.VITE_mercuryJwt,
});

export const sac = new SACClient({
    rpcUrl: import.meta.env.VITE_rpcUrl,
    networkPassphrase: import.meta.env.VITE_networkPassphrase,
});
export const native = sac.getSACClient(import.meta.env.VITE_nativeContractId)


================================================
FILE: packages/passkey-kit-sdk/README.md
================================================
# passkey-kit-sdk JS

JS library for interacting with [Soroban](https://soroban.stellar.org/) smart contract `passkey-kit-sdk` via Soroban RPC.

This library was automatically generated by Soroban CLI using a command similar to:

```bash
soroban contract bindings ts \
  --rpc-url https://soroban-testnet.stellar.org \
  --network-passphrase "Test SDF Network ; September 2015" \
  --contract-id CDSGG7BSWYWQMTY5KTZVDTC34ZESMZ75ZGSTTVHS4NIKCF4PM3GDJ4G3 \
  --output-dir ./path/to/passkey-kit-sdk
```

The network passphrase and contract ID are exported from [index.ts](./src/index.ts) in the `networks` constant. If you are the one who generated this library and you know that this contract is also deployed to other networks, feel free to update `networks` with other valid options. This will help your contract consumers use this library more easily.

# To publish or not to publish

This library is suitable for publishing to NPM. You can publish it to NPM using the `npm publish` command.

But you don't need to publish this library to NPM to use it. You can add it to your project's `package.json` using a file path:

```json
"dependencies": {
  "passkey-kit-sdk": "./path/to/this/folder"
}
```

However, we've actually encountered [frustration](https://github.com/stellar/soroban-example-dapp/pull/117#discussion_r1232873560) using local libraries with NPM in this way. Though it seems a bit messy, we suggest generating the library directly to your `node_modules` folder automatically after each install by using a `postinstall` script. We've had the least trouble with this approach. NPM will automatically remove what it sees as erroneous directories during the `install` step, and then regenerate them when it gets to your `postinstall` step, which will keep the library up-to-date with your contract.

```json
"scripts": {
  "postinstall": "soroban contract bindings ts --rpc-url https://soroban-testnet.stellar.org --network-passphrase \"Test SDF Network ; September 2015\" --id CDSGG7BSWYWQMTY5KTZVDTC34ZESMZ75ZGSTTVHS4NIKCF4PM3GDJ4G3 --name passkey-kit-sdk"
}
```

Obviously you need to adjust the above command based on the actual command you used to generate the library.

# Use it

Now that you have your library up-to-date and added to your project, you can import it in a file and see inline documentation for all of its exported methods:

```js
import { Contract, networks } from "passkey-kit-sdk"

const contract = new Contract({
  ...networks.futurenet, // for example; check which networks this library exports
  rpcUrl: '...', // use your own, or find one for testing at https://soroban.stellar.org/docs/reference/rpc#public-rpc-providers
})

contract.|
```

As long as your editor is configured to show JavaScript/TypeScript documentation, you can pause your typing at that `|` to get a list of all exports and inline-documentation for each. It exports a separate [async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) function for each method in the smart contract, with documentation for each generated from the comments the contract's author included in the original source code.



================================================
FILE: packages/passkey-kit-sdk/package.json
================================================
{
  "version": "0.6.8",
  "name": "passkey-kit-sdk",
  "type": "module",
  "main": "src/index.ts",
  "types": "types/index.d.ts",
  "scripts": {
    "prepublishOnly": "pnpm run build",
    "build": "tsc"
  },
  "dependencies": {
    "@stellar/stellar-sdk": "^13.3.0",
    "buffer": "^6.0.3"
  },
  "devDependencies": {
    "typescript": "^5.8.3"
  }
}



================================================
FILE: packages/passkey-kit-sdk/tsconfig.json
================================================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
    /* Language and Environment */
    "target": "ESNext", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
    /* Modules */
    "module": "NodeNext", /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "nodenext", /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
    /* Emit */
    "declaration": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./types", /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */
    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    // "esModuleInterop": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    // "forceConsistentCasingInFileNames": true, /* Ensure that casing is correct in imports. */
    /* Type Checking */
    // "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true, /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
  "include": [
    "src/*"
  ]
}


================================================
FILE: packages/passkey-kit-sdk/.npmignore
================================================
node_modules/



================================================
FILE: packages/passkey-kit-sdk/src/index.ts
================================================
import { Buffer } from "buffer";
import {
  AssembledTransaction,
  Client as ContractClient,
  ClientOptions as ContractClientOptions,
  MethodOptions,
  Spec as ContractSpec,
} from '@stellar/stellar-sdk/minimal/contract';
import type {
  u32,
  Option,
} from '@stellar/stellar-sdk/minimal/contract';

if (typeof window !== 'undefined') {
  //@ts-ignore Buffer exists
  window.Buffer = window.Buffer || Buffer;
}

export const Errors = {
  1: { message: "NotFound" },
  2: { message: "AlreadyExists" },
  3: { message: "MissingContext" },
  4: { message: "SignerExpired" },
  5: { message: "FailedSignerLimits" },
  6: { message: "FailedPolicySignerLimits" },
  7: { message: "SignatureKeyValueMismatch" },
  8: { message: "ClientDataJsonChallengeIncorrect" },
  9: { message: "JsonParseError" }
}
export type SignerExpiration = readonly [Option<u32>];
export type SignerLimits = readonly [Option<Map<string, Option<Array<SignerKey>>>>];
export type SignerStorage = { tag: "Persistent", values: void } | { tag: "Temporary", values: void };
export type Signer = { tag: "Policy", values: readonly [string, SignerExpiration, SignerLimits, SignerStorage] } | { tag: "Ed25519", values: readonly [Buffer, SignerExpiration, SignerLimits, SignerStorage] } | { tag: "Secp256r1", values: readonly [Buffer, Buffer, SignerExpiration, SignerLimits, SignerStorage] };
export type SignerKey = { tag: "Policy", values: readonly [string] } | { tag: "Ed25519", values: readonly [Buffer] } | { tag: "Secp256r1", values: readonly [Buffer] };
export type SignerVal = { tag: "Policy", values: readonly [SignerExpiration, SignerLimits] } | { tag: "Ed25519", values: readonly [SignerExpiration, SignerLimits] } | { tag: "Secp256r1", values: readonly [Buffer, SignerExpiration, SignerLimits] };

export interface Secp256r1Signature {
  authenticator_data: Buffer;
  client_data_json: Buffer;
  signature: Buffer;
}
export type Signature = { tag: "Policy", values: void } | { tag: "Ed25519", values: readonly [Buffer] } | { tag: "Secp256r1", values: readonly [Secp256r1Signature] };
export type Signatures = readonly [Map<SignerKey, Signature>];

export interface Client {
  /**
   * Construct and simulate a add_signer transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   */
  add_signer: ({ signer }: { signer: Signer }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a update_signer transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   */
  update_signer: ({ signer }: { signer: Signer }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a remove_signer transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   */
  remove_signer: ({ signer_key }: { signer_key: SignerKey }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a update_contract_code transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   */
  update_contract_code: ({ hash }: { hash: Buffer }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>
}
export class Client extends ContractClient {
  static async deploy<T = Client>(
    /** Constructor/Initialization Args for the contract's `__constructor` method */
    { signer }: { signer: Signer },
    /** Options for initalizing a Client as well as for calling a method, with extras specific to deploying. */
    options: MethodOptions &
      Omit<ContractClientOptions, "contractId"> & {
        /** The hash of the Wasm blob, which must already be installed on-chain. */
        wasmHash: Buffer | string;
        /** Salt used to generate the contract's ID. Passed through to {@link Operation.createCustomContract}. Default: random. */
        salt?: Buffer | Uint8Array;
        /** The format used to decode `wasmHash`, if it's provided as a string. */
        format?: "hex" | "base64";
        address?: string;
      }
  ): Promise<AssembledTransaction<T>> {
    return ContractClient.deploy({ signer }, options)
  }
  constructor(public readonly options: ContractClientOptions) {
    super(
      new ContractSpec(["AAAABAAAAAAAAAAAAAAABUVycm9yAAAAAAAACQAAAAAAAAAITm90Rm91bmQAAAABAAAAAAAAAA1BbHJlYWR5RXhpc3RzAAAAAAAAAgAAAAAAAAAOTWlzc2luZ0NvbnRleHQAAAAAAAMAAAAAAAAADVNpZ25lckV4cGlyZWQAAAAAAAAEAAAAAAAAABJGYWlsZWRTaWduZXJMaW1pdHMAAAAAAAUAAAAAAAAAGEZhaWxlZFBvbGljeVNpZ25lckxpbWl0cwAAAAYAAAAAAAAAGVNpZ25hdHVyZUtleVZhbHVlTWlzbWF0Y2gAAAAAAAAHAAAAAAAAACBDbGllbnREYXRhSnNvbkNoYWxsZW5nZUluY29ycmVjdAAAAAgAAAAAAAAADkpzb25QYXJzZUVycm9yAAAAAAAJ",
        "AAAAAQAAAAAAAAAAAAAAEFNpZ25lckV4cGlyYXRpb24AAAABAAAAAAAAAAEwAAAAAAAD6AAAAAQ=",
        "AAAAAQAAAAAAAAAAAAAADFNpZ25lckxpbWl0cwAAAAEAAAAAAAAAATAAAAAAAAPoAAAD7AAAABMAAAPoAAAD6gAAB9AAAAAJU2lnbmVyS2V5AAAA",
        "AAAAAgAAAAAAAAAAAAAADVNpZ25lclN0b3JhZ2UAAAAAAAACAAAAAAAAAAAAAAAKUGVyc2lzdGVudAAAAAAAAAAAAAAAAAAJVGVtcG9yYXJ5AAAA",
        "AAAAAgAAAAAAAAAAAAAABlNpZ25lcgAAAAAAAwAAAAEAAAAAAAAABlBvbGljeQAAAAAABAAAABMAAAfQAAAAEFNpZ25lckV4cGlyYXRpb24AAAfQAAAADFNpZ25lckxpbWl0cwAAB9AAAAANU2lnbmVyU3RvcmFnZQAAAAAAAAEAAAAAAAAAB0VkMjU1MTkAAAAABAAAA+4AAAAgAAAH0AAAABBTaWduZXJFeHBpcmF0aW9uAAAH0AAAAAxTaWduZXJMaW1pdHMAAAfQAAAADVNpZ25lclN0b3JhZ2UAAAAAAAABAAAAAAAAAAlTZWNwMjU2cjEAAAAAAAAFAAAADgAAA+4AAABBAAAH0AAAABBTaWduZXJFeHBpcmF0aW9uAAAH0AAAAAxTaWduZXJMaW1pdHMAAAfQAAAADVNpZ25lclN0b3JhZ2UAAAA=",
        "AAAAAgAAAAAAAAAAAAAACVNpZ25lcktleQAAAAAAAAMAAAABAAAAAAAAAAZQb2xpY3kAAAAAAAEAAAATAAAAAQAAAAAAAAAHRWQyNTUxOQAAAAABAAAD7gAAACAAAAABAAAAAAAAAAlTZWNwMjU2cjEAAAAAAAABAAAADg==",
        "AAAAAgAAAAAAAAAAAAAACVNpZ25lclZhbAAAAAAAAAMAAAABAAAAAAAAAAZQb2xpY3kAAAAAAAIAAAfQAAAAEFNpZ25lckV4cGlyYXRpb24AAAfQAAAADFNpZ25lckxpbWl0cwAAAAEAAAAAAAAAB0VkMjU1MTkAAAAAAgAAB9AAAAAQU2lnbmVyRXhwaXJhdGlvbgAAB9AAAAAMU2lnbmVyTGltaXRzAAAAAQAAAAAAAAAJU2VjcDI1NnIxAAAAAAAAAwAAA+4AAABBAAAH0AAAABBTaWduZXJFeHBpcmF0aW9uAAAH0AAAAAxTaWduZXJMaW1pdHM=",
        "AAAAAQAAAAAAAAAAAAAAElNlY3AyNTZyMVNpZ25hdHVyZQAAAAAAAwAAAAAAAAASYXV0aGVudGljYXRvcl9kYXRhAAAAAAAOAAAAAAAAABBjbGllbnRfZGF0YV9qc29uAAAADgAAAAAAAAAJc2lnbmF0dXJlAAAAAAAD7gAAAEA=",
        "AAAAAgAAAAAAAAAAAAAACVNpZ25hdHVyZQAAAAAAAAMAAAAAAAAAAAAAAAZQb2xpY3kAAAAAAAEAAAAAAAAAB0VkMjU1MTkAAAAAAQAAA+4AAABAAAAAAQAAAAAAAAAJU2VjcDI1NnIxAAAAAAAAAQAAB9AAAAASU2VjcDI1NnIxU2lnbmF0dXJlAAA=",
        "AAAAAQAAAAAAAAAAAAAAClNpZ25hdHVyZXMAAAAAAAEAAAAAAAAAATAAAAAAAAPsAAAH0AAAAAlTaWduZXJLZXkAAAAAAAfQAAAACVNpZ25hdHVyZQAAAA==",
        "AAAAAAAAAAAAAAANX19jb25zdHJ1Y3RvcgAAAAAAAAEAAAAAAAAABnNpZ25lcgAAAAAH0AAAAAZTaWduZXIAAAAAAAA=",
        "AAAAAAAAAAAAAAAKYWRkX3NpZ25lcgAAAAAAAQAAAAAAAAAGc2lnbmVyAAAAAAfQAAAABlNpZ25lcgAAAAAAAA==",
        "AAAAAAAAAAAAAAANdXBkYXRlX3NpZ25lcgAAAAAAAAEAAAAAAAAABnNpZ25lcgAAAAAH0AAAAAZTaWduZXIAAAAAAAA=",
        "AAAAAAAAAAAAAAANcmVtb3ZlX3NpZ25lcgAAAAAAAAEAAAAAAAAACnNpZ25lcl9rZXkAAAAAB9AAAAAJU2lnbmVyS2V5AAAAAAAAAA==",
        "AAAAAAAAAAAAAAAUdXBkYXRlX2NvbnRyYWN0X2NvZGUAAAABAAAAAAAAAARoYXNoAAAD7gAAACAAAAAA",
        "AAAAAAAAAAAAAAAMX19jaGVja19hdXRoAAAAAwAAAAAAAAARc2lnbmF0dXJlX3BheWxvYWQAAAAAAAPuAAAAIAAAAAAAAAAKc2lnbmF0dXJlcwAAAAAH0AAAAApTaWduYXR1cmVzAAAAAAAAAAAADWF1dGhfY29udGV4dHMAAAAAAAPqAAAH0AAAAAdDb250ZXh0AAAAAAEAAAPpAAAD7QAAAAAAAAAD"]),
      options
    )
  }
  public readonly fromJSON = {
    add_signer: this.txFromJSON<null>,
    update_signer: this.txFromJSON<null>,
    remove_signer: this.txFromJSON<null>,
    update_contract_code: this.txFromJSON<null>
  }
}


================================================
FILE: packages/sac-sdk/README.md
================================================
# sac-sdk JS

JS library for interacting with [Soroban](https://soroban.stellar.org/) smart contract `sac-sdk` via Soroban RPC.

This library was automatically generated by Soroban CLI using a command similar to:

```bash
soroban contract bindings ts \
  --rpc-url https://soroban-testnet.stellar.org \
  --network-passphrase "Test SDF Network ; September 2015" \
  --contract-id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC \
  --output-dir ./path/to/sac-sdk
```

The network passphrase and contract ID are exported from [index.ts](./src/index.ts) in the `networks` constant. If you are the one who generated this library and you know that this contract is also deployed to other networks, feel free to update `networks` with other valid options. This will help your contract consumers use this library more easily.

# To publish or not to publish

This library is suitable for publishing to NPM. You can publish it to NPM using the `npm publish` command.

But you don't need to publish this library to NPM to use it. You can add it to your project's `package.json` using a file path:

```json
"dependencies": {
  "sac-sdk": "./path/to/this/folder"
}
```

However, we've actually encountered [frustration](https://github.com/stellar/soroban-example-dapp/pull/117#discussion_r1232873560) using local libraries with NPM in this way. Though it seems a bit messy, we suggest generating the library directly to your `node_modules` folder automatically after each install by using a `postinstall` script. We've had the least trouble with this approach. NPM will automatically remove what it sees as erroneous directories during the `install` step, and then regenerate them when it gets to your `postinstall` step, which will keep the library up-to-date with your contract.

```json
"scripts": {
  "postinstall": "soroban contract bindings ts --rpc-url https://soroban-testnet.stellar.org --network-passphrase \"Test SDF Network ; September 2015\" --id CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC --name sac-sdk"
}
```

Obviously you need to adjust the above command based on the actual command you used to generate the library.

# Use it

Now that you have your library up-to-date and added to your project, you can import it in a file and see inline documentation for all of its exported methods:

```js
import { Contract, networks } from "sac-sdk"

const contract = new Contract({
  ...networks.futurenet, // for example; check which networks this library exports
  rpcUrl: '...', // use your own, or find one for testing at https://soroban.stellar.org/docs/reference/rpc#public-rpc-providers
})

contract.|
```

As long as your editor is configured to show JavaScript/TypeScript documentation, you can pause your typing at that `|` to get a list of all exports and inline-documentation for each. It exports a separate [async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) function for each method in the smart contract, with documentation for each generated from the comments the contract's author included in the original source code.



================================================
FILE: packages/sac-sdk/package.json
================================================
{
  "version": "0.3.8",
  "name": "sac-sdk",
  "type": "module",
  "main": "src/index.ts",
  "types": "types/index.d.ts",
  "scripts": {
    "prepublishOnly": "pnpm run build",
    "build": "tsc"
  },
  "dependencies": {
    "@stellar/stellar-sdk": "^13.3.0",
    "buffer": "^6.0.3"
  },
  "devDependencies": {
    "typescript": "^5.8.3"
  }
}



================================================
FILE: packages/sac-sdk/tsconfig.json
================================================
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig to read more about this file */
    /* Projects */
    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
    /* Language and Environment */
    "target": "ESNext", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
    /* Modules */
    "module": "NodeNext", /* Specify what module code is generated. */
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    "moduleResolution": "nodenext", /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
    // "resolveJsonModule": true,                        /* Enable importing .json files. */
    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
    /* Emit */
    "declaration": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
    "outDir": "./types", /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */
    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    // "esModuleInterop": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    // "forceConsistentCasingInFileNames": true, /* Ensure that casing is correct in imports. */
    /* Type Checking */
    // "strict": true, /* Enable all strict type-checking options. */
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
    "strictNullChecks": true, /* When type checking, take into account 'null' and 'undefined'. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  },
  "include": [
    "src/*"
  ]
}


================================================
FILE: packages/sac-sdk/.npmignore
================================================
node_modules/



================================================
FILE: packages/sac-sdk/src/index.ts
================================================
import { Buffer } from "buffer";
import {
  AssembledTransaction,
  Client as ContractClient,
  ClientOptions as ContractClientOptions,
  MethodOptions,
  Spec as ContractSpec,
} from '@stellar/stellar-sdk/minimal/contract';
import type {
  u32,
  i128,
} from '@stellar/stellar-sdk/minimal/contract';

if (typeof window !== 'undefined') {
  //@ts-ignore Buffer exists
  window.Buffer = window.Buffer || Buffer;
}

export interface Client {
  /**
   * Construct and simulate a allowance transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns the allowance for `spender` to transfer from `from`.
   * 
   * The amount returned is the amount that spender is allowed to transfer
   * out of from's balance. When the spender transfers amounts, the allowance
   * will be reduced by the amount transferred.
   * 
   * # Arguments
   * 
   * * `from` - The address holding the balance of tokens to be drawn from.
   * * `spender` - The address spending the tokens held by `from`.
   */
  allowance: ({ from, spender }: { from: string, spender: string }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<i128>>

  /**
   * Construct and simulate a authorized transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns true if `id` is authorized to use its balance.
   * 
   * # Arguments
   * 
   * * `id` - The address for which token authorization is being checked.
   */
  authorized: ({ id }: { id: string }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<boolean>>

  /**
   * Construct and simulate a approve transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Set the allowance by `amount` for `spender` to transfer/burn from
   * `from`.
   * 
   * The amount set is the amount that spender is approved to transfer out of
   * from's balance. The spender will be allowed to transfer amounts, and
   * when an amount is transferred the allowance will be reduced by the
   * amount transferred.
   * 
   * # Arguments
   * 
   * * `from` - The address holding the balance of tokens to be drawn from.
   * * `spender` - The address being authorized to spend the tokens held by
   * `from`.
   * * `amount` - The tokens to be made available to `spender`.
   * * `expiration_ledger` - The ledger number where this allowance expires. Cannot
   * be less than the current ledger number unless the amount is being set to 0.
   * An expired entry (where expiration_ledger < the current ledger number)
   * should be treated as a 0 amount allowance.
   * 
   * # Events
   * 
   * Emits an event with topics `["approve", from: Address,
   * spender: Address], data = [amount: i128, expiration_ledger: u32]`
   */
  approve: ({ from, spender, amount, expiration_ledger }: { from: string, spender: string, amount: i128, expiration_ledger: u32 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a balance transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns the balance of `id`.
   * 
   * # Arguments
   * 
   * * `id` - The address for which a balance is being queried. If the
   * address has no existing balance, returns 0.
   */
  balance: ({ id }: { id: string }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<i128>>

  /**
   * Construct and simulate a burn transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Burn `amount` from `from`.
   * 
   * Reduces from's balance by the amount, without transferring the balance
   * to another holder's balance.
   * 
   * # Arguments
   * 
   * * `from` - The address holding the balance of tokens which will be
   * burned from.
   * * `amount` - The amount of tokens to be burned.
   * 
   * # Events
   * 
   * Emits an event with topics `["burn", from: Address], data = amount:
   * i128`
   */
  burn: ({ from, amount }: { from: string, amount: i128 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a burn_from transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Burn `amount` from `from`, consuming the allowance of `spender`.
   * 
   * Reduces from's balance by the amount, without transferring the balance
   * to another holder's balance.
   * 
   * The spender will be allowed to burn the amount from from's balance, if
   * the amount is less than or equal to the allowance that the spender has
   * on the from's balance. The spender's allowance on from's balance will be
   * reduced by the amount.
   * 
   * # Arguments
   * 
   * * `spender` - The address authorizing the burn, and having its allowance
   * consumed during the burn.
   * * `from` - The address holding the balance of tokens which will be
   * burned from.
   * * `amount` - The amount of tokens to be burned.
   * 
   * # Events
   * 
   * Emits an event with topics `["burn", from: Address], data = amount:
   * i128`
   */
  burn_from: ({ spender, from, amount }: { spender: string, from: string, amount: i128 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a clawback transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Clawback `amount` from `from` account. `amount` is burned in the
   * clawback process.
   * 
   * # Arguments
   * 
   * * `from` - The address holding the balance from which the clawback will
   * take tokens.
   * * `amount` - The amount of tokens to be clawed back.
   * 
   * # Events
   * 
   * Emits an event with topics `["clawback", admin: Address, to: Address],
   * data = amount: i128`
   */
  clawback: ({ from, amount }: { from: string, amount: i128 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a decimals transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns the number of decimals used to represent amounts of this token.
   * 
   * # Panics
   * 
   * If the contract has not yet been initialized.
   */
  decimals: (options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<u32>>

  /**
   * Construct and simulate a mint transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Mints `amount` to `to`.
   * 
   * # Arguments
   * 
   * * `to` - The address which will receive the minted tokens.
   * * `amount` - The amount of tokens to be minted.
   * 
   * # Events
   * 
   * Emits an event with topics `["mint", admin: Address, to: Address], data
   * = amount: i128`
   */
  mint: ({ to, amount }: { to: string, amount: i128 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a name transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns the name for this token.
   * 
   * # Panics
   * 
   * If the contract has not yet been initialized.
   */
  name: (options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<string>>

  /**
   * Construct and simulate a set_admin transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Sets the administrator to the specified address `new_admin`.
   * 
   * # Arguments
   * 
   * * `new_admin` - The address which will henceforth be the administrator
   * of this token contract.
   * 
   * # Events
   * 
   * Emits an event with topics `["set_admin", admin: Address], data =
   * [new_admin: Address]`
   */
  set_admin: ({ new_admin }: { new_admin: string }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a admin transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns the admin of the contract.
   * 
   * # Panics
   * 
   * If the admin is not set.
   */
  admin: (options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<string>>

  /**
   * Construct and simulate a set_authorized transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Sets whether the account is authorized to use its balance. If
   * `authorized` is true, `id` should be able to use its balance.
   * 
   * # Arguments
   * 
   * * `id` - The address being (de-)authorized.
   * * `authorize` - Whether or not `id` can use its balance.
   * 
   * # Events
   * 
   * Emits an event with topics `["set_authorized", id: Address], data =
   * [authorize: bool]`
   */
  set_authorized: ({ id, authorize }: { id: string, authorize: boolean }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a symbol transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Returns the symbol for this token.
   * 
   * # Panics
   * 
   * If the contract has not yet been initialized.
   */
  symbol: (options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<string>>

  /**
   * Construct and simulate a transfer transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Transfer `amount` from `from` to `to`.
   * 
   * # Arguments
   * 
   * * `from` - The address holding the balance of tokens which will be
   * withdrawn from.
   * * `to` - The address which will receive the transferred tokens.
   * * `amount` - The amount of tokens to be transferred.
   * 
   * # Events
   * 
   * Emits an event with topics `["transfer", from: Address, to: Address],
   * data = amount: i128`
   */
  transfer: ({ from, to, amount }: { from: string, to: string, amount: i128 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>

  /**
   * Construct and simulate a transfer_from transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.
   * Transfer `amount` from `from` to `to`, consuming the allowance that
   * `spender` has on `from`'s balance. Authorized by spender
   * (`spender.require_auth()`).
   * 
   * The spender will be allowed to transfer the amount from from's balance
   * if the amount is less than or equal to the allowance that the spender
   * has on the from's balance. The spender's allowance on from's balance
   * will be reduced by the amount.
   * 
   * # Arguments
   * 
   * * `spender` - The address authorizing the transfer, and having its
   * allowance consumed during the transfer.
   * * `from` - The address holding the balance of tokens which will be
   * withdrawn from.
   * * `to` - The address which will receive the transferred tokens.
   * * `amount` - The amount of tokens to be transferred.
   * 
   * # Events
   * 
   * Emits an event with topics `["transfer", from: Address, to: Address],
   * data = amount: i128`
   */
  transfer_from: ({ spender, from, to, amount }: { spender: string, from: string, to: string, amount: i128 }, options?: {
    /**
     * The fee to pay for the transaction. Default: BASE_FEE
     */
    fee?: number;

    /**
     * The maximum amount of time to wait for the transaction to complete. Default: DEFAULT_TIMEOUT
     */
    timeoutInSeconds?: number;

    /**
     * Whether to automatically simulate the transaction when constructing the AssembledTransaction. Default: true
     */
    simulate?: boolean;
  }) => Promise<AssembledTransaction<null>>
}
export class Client extends ContractClient {
  static async deploy<T = Client>(
    /** Options for initalizing a Client as well as for calling a method, with extras specific to deploying. */
    options: MethodOptions &
      Omit<ContractClientOptions, "contractId"> & {
        /** The hash of the Wasm blob, which must already be installed on-chain. */
        wasmHash: Buffer | string;
        /** Salt used to generate the contract's ID. Passed through to {@link Operation.createCustomContract}. Default: random. */
        salt?: Buffer | Uint8Array;
        /** The format used to decode `wasmHash`, if it's provided as a string. */
        format?: "hex" | "base64";
        address?: string;
      }
  ): Promise<AssembledTransaction<T>> {
    return ContractClient.deploy(null, options)
  }
  constructor(public readonly options: ContractClientOptions) {
    super(
      new ContractSpec(["AAAAAAAAAYpSZXR1cm5zIHRoZSBhbGxvd2FuY2UgZm9yIGBzcGVuZGVyYCB0byB0cmFuc2ZlciBmcm9tIGBmcm9tYC4KClRoZSBhbW91bnQgcmV0dXJuZWQgaXMgdGhlIGFtb3VudCB0aGF0IHNwZW5kZXIgaXMgYWxsb3dlZCB0byB0cmFuc2ZlcgpvdXQgb2YgZnJvbSdzIGJhbGFuY2UuIFdoZW4gdGhlIHNwZW5kZXIgdHJhbnNmZXJzIGFtb3VudHMsIHRoZSBhbGxvd2FuY2UKd2lsbCBiZSByZWR1Y2VkIGJ5IHRoZSBhbW91bnQgdHJhbnNmZXJyZWQuCgojIEFyZ3VtZW50cwoKKiBgZnJvbWAgLSBUaGUgYWRkcmVzcyBob2xkaW5nIHRoZSBiYWxhbmNlIG9mIHRva2VucyB0byBiZSBkcmF3biBmcm9tLgoqIGBzcGVuZGVyYCAtIFRoZSBhZGRyZXNzIHNwZW5kaW5nIHRoZSB0b2tlbnMgaGVsZCBieSBgZnJvbWAuAAAAAAAJYWxsb3dhbmNlAAAAAAAAAgAAAAAAAAAEZnJvbQAAABMAAAAAAAAAB3NwZW5kZXIAAAAAEwAAAAEAAAAL",
        "AAAAAAAAAIlSZXR1cm5zIHRydWUgaWYgYGlkYCBpcyBhdXRob3JpemVkIHRvIHVzZSBpdHMgYmFsYW5jZS4KCiMgQXJndW1lbnRzCgoqIGBpZGAgLSBUaGUgYWRkcmVzcyBmb3Igd2hpY2ggdG9rZW4gYXV0aG9yaXphdGlvbiBpcyBiZWluZyBjaGVja2VkLgAAAAAAAAphdXRob3JpemVkAAAAAAABAAAAAAAAAAJpZAAAAAAAEwAAAAEAAAAB",
        "AAAAAAAAA59TZXQgdGhlIGFsbG93YW5jZSBieSBgYW1vdW50YCBmb3IgYHNwZW5kZXJgIHRvIHRyYW5zZmVyL2J1cm4gZnJvbQpgZnJvbWAuCgpUaGUgYW1vdW50IHNldCBpcyB0aGUgYW1vdW50IHRoYXQgc3BlbmRlciBpcyBhcHByb3ZlZCB0byB0cmFuc2ZlciBvdXQgb2YKZnJvbSdzIGJhbGFuY2UuIFRoZSBzcGVuZGVyIHdpbGwgYmUgYWxsb3dlZCB0byB0cmFuc2ZlciBhbW91bnRzLCBhbmQKd2hlbiBhbiBhbW91bnQgaXMgdHJhbnNmZXJyZWQgdGhlIGFsbG93YW5jZSB3aWxsIGJlIHJlZHVjZWQgYnkgdGhlCmFtb3VudCB0cmFuc2ZlcnJlZC4KCiMgQXJndW1lbnRzCgoqIGBmcm9tYCAtIFRoZSBhZGRyZXNzIGhvbGRpbmcgdGhlIGJhbGFuY2Ugb2YgdG9rZW5zIHRvIGJlIGRyYXduIGZyb20uCiogYHNwZW5kZXJgIC0gVGhlIGFkZHJlc3MgYmVpbmcgYXV0aG9yaXplZCB0byBzcGVuZCB0aGUgdG9rZW5zIGhlbGQgYnkKYGZyb21gLgoqIGBhbW91bnRgIC0gVGhlIHRva2VucyB0byBiZSBtYWRlIGF2YWlsYWJsZSB0byBgc3BlbmRlcmAuCiogYGV4cGlyYXRpb25fbGVkZ2VyYCAtIFRoZSBsZWRnZXIgbnVtYmVyIHdoZXJlIHRoaXMgYWxsb3dhbmNlIGV4cGlyZXMuIENhbm5vdApiZSBsZXNzIHRoYW4gdGhlIGN1cnJlbnQgbGVkZ2VyIG51bWJlciB1bmxlc3MgdGhlIGFtb3VudCBpcyBiZWluZyBzZXQgdG8gMC4KQW4gZXhwaXJlZCBlbnRyeSAod2hlcmUgZXhwaXJhdGlvbl9sZWRnZXIgPCB0aGUgY3VycmVudCBsZWRnZXIgbnVtYmVyKQpzaG91bGQgYmUgdHJlYXRlZCBhcyBhIDAgYW1vdW50IGFsbG93YW5jZS4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJhcHByb3ZlIiwgZnJvbTogQWRkcmVzcywKc3BlbmRlcjogQWRkcmVzc10sIGRhdGEgPSBbYW1vdW50OiBpMTI4LCBleHBpcmF0aW9uX2xlZGdlcjogdTMyXWAAAAAAB2FwcHJvdmUAAAAABAAAAAAAAAAEZnJvbQAAABMAAAAAAAAAB3NwZW5kZXIAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAAAAABFleHBpcmF0aW9uX2xlZGdlcgAAAAAAAAQAAAAA",
        "AAAAAAAAAJhSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIGBpZGAuCgojIEFyZ3VtZW50cwoKKiBgaWRgIC0gVGhlIGFkZHJlc3MgZm9yIHdoaWNoIGEgYmFsYW5jZSBpcyBiZWluZyBxdWVyaWVkLiBJZiB0aGUKYWRkcmVzcyBoYXMgbm8gZXhpc3RpbmcgYmFsYW5jZSwgcmV0dXJucyAwLgAAAAdiYWxhbmNlAAAAAAEAAAAAAAAAAmlkAAAAAAATAAAAAQAAAAs=",
        "AAAAAAAAAWJCdXJuIGBhbW91bnRgIGZyb20gYGZyb21gLgoKUmVkdWNlcyBmcm9tJ3MgYmFsYW5jZSBieSB0aGUgYW1vdW50LCB3aXRob3V0IHRyYW5zZmVycmluZyB0aGUgYmFsYW5jZQp0byBhbm90aGVyIGhvbGRlcidzIGJhbGFuY2UuCgojIEFyZ3VtZW50cwoKKiBgZnJvbWAgLSBUaGUgYWRkcmVzcyBob2xkaW5nIHRoZSBiYWxhbmNlIG9mIHRva2VucyB3aGljaCB3aWxsIGJlCmJ1cm5lZCBmcm9tLgoqIGBhbW91bnRgIC0gVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gYmUgYnVybmVkLgoKIyBFdmVudHMKCkVtaXRzIGFuIGV2ZW50IHdpdGggdG9waWNzIGBbImJ1cm4iLCBmcm9tOiBBZGRyZXNzXSwgZGF0YSA9IGFtb3VudDoKaTEyOGAAAAAAAARidXJuAAAAAgAAAAAAAAAEZnJvbQAAABMAAAAAAAAABmFtb3VudAAAAAAACwAAAAA=",
        "AAAAAAAAAtpCdXJuIGBhbW91bnRgIGZyb20gYGZyb21gLCBjb25zdW1pbmcgdGhlIGFsbG93YW5jZSBvZiBgc3BlbmRlcmAuCgpSZWR1Y2VzIGZyb20ncyBiYWxhbmNlIGJ5IHRoZSBhbW91bnQsIHdpdGhvdXQgdHJhbnNmZXJyaW5nIHRoZSBiYWxhbmNlCnRvIGFub3RoZXIgaG9sZGVyJ3MgYmFsYW5jZS4KClRoZSBzcGVuZGVyIHdpbGwgYmUgYWxsb3dlZCB0byBidXJuIHRoZSBhbW91bnQgZnJvbSBmcm9tJ3MgYmFsYW5jZSwgaWYKdGhlIGFtb3VudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGFsbG93YW5jZSB0aGF0IHRoZSBzcGVuZGVyIGhhcwpvbiB0aGUgZnJvbSdzIGJhbGFuY2UuIFRoZSBzcGVuZGVyJ3MgYWxsb3dhbmNlIG9uIGZyb20ncyBiYWxhbmNlIHdpbGwgYmUKcmVkdWNlZCBieSB0aGUgYW1vdW50LgoKIyBBcmd1bWVudHMKCiogYHNwZW5kZXJgIC0gVGhlIGFkZHJlc3MgYXV0aG9yaXppbmcgdGhlIGJ1cm4sIGFuZCBoYXZpbmcgaXRzIGFsbG93YW5jZQpjb25zdW1lZCBkdXJpbmcgdGhlIGJ1cm4uCiogYGZyb21gIC0gVGhlIGFkZHJlc3MgaG9sZGluZyB0aGUgYmFsYW5jZSBvZiB0b2tlbnMgd2hpY2ggd2lsbCBiZQpidXJuZWQgZnJvbS4KKiBgYW1vdW50YCAtIFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIGJlIGJ1cm5lZC4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJidXJuIiwgZnJvbTogQWRkcmVzc10sIGRhdGEgPSBhbW91bnQ6CmkxMjhgAAAAAAAJYnVybl9mcm9tAAAAAAAAAwAAAAAAAAAHc3BlbmRlcgAAAAATAAAAAAAAAARmcm9tAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA==",
        "AAAAAAAAAVFDbGF3YmFjayBgYW1vdW50YCBmcm9tIGBmcm9tYCBhY2NvdW50LiBgYW1vdW50YCBpcyBidXJuZWQgaW4gdGhlCmNsYXdiYWNrIHByb2Nlc3MuCgojIEFyZ3VtZW50cwoKKiBgZnJvbWAgLSBUaGUgYWRkcmVzcyBob2xkaW5nIHRoZSBiYWxhbmNlIGZyb20gd2hpY2ggdGhlIGNsYXdiYWNrIHdpbGwKdGFrZSB0b2tlbnMuCiogYGFtb3VudGAgLSBUaGUgYW1vdW50IG9mIHRva2VucyB0byBiZSBjbGF3ZWQgYmFjay4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJjbGF3YmFjayIsIGFkbWluOiBBZGRyZXNzLCB0bzogQWRkcmVzc10sCmRhdGEgPSBhbW91bnQ6IGkxMjhgAAAAAAAACGNsYXdiYWNrAAAAAgAAAAAAAAAEZnJvbQAAABMAAAAAAAAABmFtb3VudAAAAAAACwAAAAA=",
        "AAAAAAAAAIBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdXNlZCB0byByZXByZXNlbnQgYW1vdW50cyBvZiB0aGlzIHRva2VuLgoKIyBQYW5pY3MKCklmIHRoZSBjb250cmFjdCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLgAAAAhkZWNpbWFscwAAAAAAAAABAAAABA==",
        "AAAAAAAAAPNNaW50cyBgYW1vdW50YCB0byBgdG9gLgoKIyBBcmd1bWVudHMKCiogYHRvYCAtIFRoZSBhZGRyZXNzIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgbWludGVkIHRva2Vucy4KKiBgYW1vdW50YCAtIFRoZSBhbW91bnQgb2YgdG9rZW5zIHRvIGJlIG1pbnRlZC4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJtaW50IiwgYWRtaW46IEFkZHJlc3MsIHRvOiBBZGRyZXNzXSwgZGF0YQo9IGFtb3VudDogaTEyOGAAAAAABG1pbnQAAAACAAAAAAAAAAJ0bwAAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA==",
        "AAAAAAAAAFlSZXR1cm5zIHRoZSBuYW1lIGZvciB0aGlzIHRva2VuLgoKIyBQYW5pY3MKCklmIHRoZSBjb250cmFjdCBoYXMgbm90IHlldCBiZWVuIGluaXRpYWxpemVkLgAAAAAAAARuYW1lAAAAAAAAAAEAAAAQ",
        "AAAAAAAAAQxTZXRzIHRoZSBhZG1pbmlzdHJhdG9yIHRvIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBgbmV3X2FkbWluYC4KCiMgQXJndW1lbnRzCgoqIGBuZXdfYWRtaW5gIC0gVGhlIGFkZHJlc3Mgd2hpY2ggd2lsbCBoZW5jZWZvcnRoIGJlIHRoZSBhZG1pbmlzdHJhdG9yCm9mIHRoaXMgdG9rZW4gY29udHJhY3QuCgojIEV2ZW50cwoKRW1pdHMgYW4gZXZlbnQgd2l0aCB0b3BpY3MgYFsic2V0X2FkbWluIiwgYWRtaW46IEFkZHJlc3NdLCBkYXRhID0KW25ld19hZG1pbjogQWRkcmVzc11gAAAACXNldF9hZG1pbgAAAAAAAAEAAAAAAAAACW5ld19hZG1pbgAAAAAAABMAAAAA",
        "AAAAAAAAAEZSZXR1cm5zIHRoZSBhZG1pbiBvZiB0aGUgY29udHJhY3QuCgojIFBhbmljcwoKSWYgdGhlIGFkbWluIGlzIG5vdCBzZXQuAAAAAAAFYWRtaW4AAAAAAAAAAAAAAQAAABM=",
        "AAAAAAAAAVBTZXRzIHdoZXRoZXIgdGhlIGFjY291bnQgaXMgYXV0aG9yaXplZCB0byB1c2UgaXRzIGJhbGFuY2UuIElmCmBhdXRob3JpemVkYCBpcyB0cnVlLCBgaWRgIHNob3VsZCBiZSBhYmxlIHRvIHVzZSBpdHMgYmFsYW5jZS4KCiMgQXJndW1lbnRzCgoqIGBpZGAgLSBUaGUgYWRkcmVzcyBiZWluZyAoZGUtKWF1dGhvcml6ZWQuCiogYGF1dGhvcml6ZWAgLSBXaGV0aGVyIG9yIG5vdCBgaWRgIGNhbiB1c2UgaXRzIGJhbGFuY2UuCgojIEV2ZW50cwoKRW1pdHMgYW4gZXZlbnQgd2l0aCB0b3BpY3MgYFsic2V0X2F1dGhvcml6ZWQiLCBpZDogQWRkcmVzc10sIGRhdGEgPQpbYXV0aG9yaXplOiBib29sXWAAAAAOc2V0X2F1dGhvcml6ZWQAAAAAAAIAAAAAAAAAAmlkAAAAAAATAAAAAAAAAAlhdXRob3JpemUAAAAAAAABAAAAAA==",
        "AAAAAAAAAFtSZXR1cm5zIHRoZSBzeW1ib2wgZm9yIHRoaXMgdG9rZW4uCgojIFBhbmljcwoKSWYgdGhlIGNvbnRyYWN0IGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQuAAAAAAZzeW1ib2wAAAAAAAAAAAABAAAAEA==",
        "AAAAAAAAAWJUcmFuc2ZlciBgYW1vdW50YCBmcm9tIGBmcm9tYCB0byBgdG9gLgoKIyBBcmd1bWVudHMKCiogYGZyb21gIC0gVGhlIGFkZHJlc3MgaG9sZGluZyB0aGUgYmFsYW5jZSBvZiB0b2tlbnMgd2hpY2ggd2lsbCBiZQp3aXRoZHJhd24gZnJvbS4KKiBgdG9gIC0gVGhlIGFkZHJlc3Mgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSB0cmFuc2ZlcnJlZCB0b2tlbnMuCiogYGFtb3VudGAgLSBUaGUgYW1vdW50IG9mIHRva2VucyB0byBiZSB0cmFuc2ZlcnJlZC4KCiMgRXZlbnRzCgpFbWl0cyBhbiBldmVudCB3aXRoIHRvcGljcyBgWyJ0cmFuc2ZlciIsIGZyb206IEFkZHJlc3MsIHRvOiBBZGRyZXNzXSwKZGF0YSA9IGFtb3VudDogaTEyOGAAAAAAAAh0cmFuc2ZlcgAAAAMAAAAAAAAABGZyb20AAAATAAAAAAAAAAJ0bwAAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA==",
        "AAAAAAAAAzFUcmFuc2ZlciBgYW1vdW50YCBmcm9tIGBmcm9tYCB0byBgdG9gLCBjb25zdW1pbmcgdGhlIGFsbG93YW5jZSB0aGF0CmBzcGVuZGVyYCBoYXMgb24gYGZyb21gJ3MgYmFsYW5jZS4gQXV0aG9yaXplZCBieSBzcGVuZGVyCihgc3BlbmRlci5yZXF1aXJlX2F1dGgoKWApLgoKVGhlIHNwZW5kZXIgd2lsbCBiZSBhbGxvd2VkIHRvIHRyYW5zZmVyIHRoZSBhbW91bnQgZnJvbSBmcm9tJ3MgYmFsYW5jZQppZiB0aGUgYW1vdW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgYWxsb3dhbmNlIHRoYXQgdGhlIHNwZW5kZXIKaGFzIG9uIHRoZSBmcm9tJ3MgYmFsYW5jZS4gVGhlIHNwZW5kZXIncyBhbGxvd2FuY2Ugb24gZnJvbSdzIGJhbGFuY2UKd2lsbCBiZSByZWR1Y2VkIGJ5IHRoZSBhbW91bnQuCgojIEFyZ3VtZW50cwoKKiBgc3BlbmRlcmAgLSBUaGUgYWRkcmVzcyBhdXRob3JpemluZyB0aGUgdHJhbnNmZXIsIGFuZCBoYXZpbmcgaXRzCmFsbG93YW5jZSBjb25zdW1lZCBkdXJpbmcgdGhlIHRyYW5zZmVyLgoqIGBmcm9tYCAtIFRoZSBhZGRyZXNzIGhvbGRpbmcgdGhlIGJhbGFuY2Ugb2YgdG9rZW5zIHdoaWNoIHdpbGwgYmUKd2l0aGRyYXduIGZyb20uCiogYHRvYCAtIFRoZSBhZGRyZXNzIHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgdHJhbnNmZXJyZWQgdG9rZW5zLgoqIGBhbW91bnRgIC0gVGhlIGFtb3VudCBvZiB0b2tlbnMgdG8gYmUgdHJhbnNmZXJyZWQuCgojIEV2ZW50cwoKRW1pdHMgYW4gZXZlbnQgd2l0aCB0b3BpY3MgYFsidHJhbnNmZXIiLCBmcm9tOiBBZGRyZXNzLCB0bzogQWRkcmVzc10sCmRhdGEgPSBhbW91bnQ6IGkxMjhgAAAAAAAADXRyYW5zZmVyX2Zyb20AAAAAAAAEAAAAAAAAAAdzcGVuZGVyAAAAABMAAAAAAAAABGZyb20AAAATAAAAAAAAAAJ0bwAAAAAAEwAAAAAAAAAGYW1vdW50AAAAAAALAAAAAA=="]),
      options
    )
  }
  public readonly fromJSON = {
    allowance: this.txFromJSON<i128>,
    authorized: this.txFromJSON<boolean>,
    approve: this.txFromJSON<null>,
    balance: this.txFromJSON<i128>,
    burn: this.txFromJSON<null>,
    burn_from: this.txFromJSON<null>,
    clawback: this.txFromJSON<null>,
    decimals: this.txFromJSON<u32>,
    mint: this.txFromJSON<null>,
    name: this.txFromJSON<string>,
    set_admin: this.txFromJSON<null>,
    admin: this.txFromJSON<string>,
    set_authorized: this.txFromJSON<null>,
    symbol: this.txFromJSON<string>,
    transfer: this.txFromJSON<null>,
    transfer_from: this.txFromJSON<null>
  }
}


================================================
FILE: src/base.ts
================================================
import { Server } from "@stellar/stellar-sdk/minimal/rpc"

// TODO consider adding support for a signAuthEntry method that conforms to the ed25519 signature scheme of this passkey interface
// once we do that we can clean the code a little with the `xdr.HashIdPreimage.envelopeTypeSorobanAuthorization` stuff
// ... note I've re-read the above and I've currently got no clue what this is asking for. Maybe check git-blame for when it was added to try and find some context
// actually this is just talking about adding support for signing transactions with an ed25519 key as well as a passkey. Simple enough

export class PasskeyBase {
    public rpcUrl: string | undefined
    public rpc: Server | undefined
    
    constructor(rpcUrl?: string) {
        if (rpcUrl) {
            this.rpcUrl = rpcUrl
            this.rpc = new Server(rpcUrl)
        }
    }
}


================================================
FILE: src/index.ts
================================================
export { SignerStore, SignerKey, type Signer, type SignerLimits } from './types'
export { PasskeyKit } from "./kit"
export { PasskeyServer } from "./server"
export { SACClient } from "./sac"
export { Client as PasskeyClient } from 'passkey-kit-sdk'


================================================
FILE: src/kit.ts
================================================
import { Client as PasskeyClient, type Signature, type SignerKey as SDKSignerKey, type SignerLimits as SDKSignerLimits } from 'passkey-kit-sdk'
import { StrKey, hash, xdr, Keypair, Address, TransactionBuilder, Operation } from '@stellar/stellar-sdk/minimal'
import type { AuthenticationResponseJSON, AuthenticatorAttestationResponseJSON, AuthenticatorSelectionCriteria } from "@simplewebauthn/types"
import { startRegistration, startAuthentication } from "@simplewebauthn/browser"
import { Buffer } from 'buffer'
import base64url from 'base64url'
import type { SignerKey, SignerLimits, SignerStore } from './types'
import { PasskeyBase } from './base'
import { AssembledTransaction, basicNodeSigner, type AssembledTransactionOptions, type Tx } from '@stellar/stellar-sdk/minimal/contract'
import type { Server } from '@stellar/stellar-sdk/minimal/rpc'

export class PasskeyKit extends PasskeyBase {
    declare rpc: Server
    declare rpcUrl: string

    private walletKeypair: Keypair
    private walletPublicKey: string
    private walletWasmHash: string
    private timeoutInSeconds: number
    private WebAuthn: {
        startRegistration: typeof startRegistration,
        startAuthentication: typeof startAuthentication
    }

    public keyId: string | undefined
    public networkPassphrase: string
    public wallet: PasskeyClient | undefined

    constructor(options: {
        rpcUrl: string,
        networkPassphrase: string,
        walletWasmHash: string,
        timeoutInSeconds?: number,
        WebAuthn?: {
            startRegistration: typeof startRegistration,
            startAuthentication: typeof startAuthentication
        }
    }) {
        const { rpcUrl, networkPassphrase, walletWasmHash, WebAuthn } = options

        super(rpcUrl)

        this.networkPassphrase = networkPassphrase
        // this account exists as the seed source for deploying new wallets
        // not using the genesis wallet as on mainnet the account has no usable signers
        // there's a chance this isn't the best move and should instead be a constructor variable
        // alternatively when we create a new wallet we shouldn't inherit the source as the auth entry signer
        // Keypair.fromRawEd25519Seed(hash(Buffer.from(this.networkPassphrase)))
        this.walletKeypair = Keypair.fromRawEd25519Seed(hash(Buffer.from('kalepail')));
        this.walletPublicKey = this.walletKeypair.publicKey()
        this.walletWasmHash = walletWasmHash
        this.timeoutInSeconds = options.timeoutInSeconds || 30 // Launchtube requires <= 30 second timeout so let's default to that
        this.WebAuthn = WebAuthn || { startRegistration, startAuthentication }
    }

    public async createWallet(app: string, user: string) {
        const { rawResponse, keyId, keyIdBase64, publicKey } = await this.createKey(app, user)

        const at = await PasskeyClient.deploy(
            {
                signer: {
                    tag: 'Secp256r1',
                    values: [
                        keyId,
                        publicKey,
                        [undefined],
                        [undefined],
                        { tag: 'Persistent', values: undefined },
                    ]
                }
            },
            {
                rpcUrl: this.rpcUrl,
                wasmHash: this.walletWasmHash,
                networkPassphrase: this.networkPassphrase,
                publicKey: this.walletPublicKey,
                salt: hash(keyId),
                timeoutInSeconds: this.timeoutInSeconds,
            }
        )

        const contractId = at.result.options.contractId

        this.wallet = new PasskeyClient({
            contractId,
            networkPassphrase: this.networkPassphrase,
            rpcUrl: this.rpcUrl
        })

        await at.sign({
            signTransaction: basicNodeSigner(this.walletKeypair, this.networkPassphrase).signTransaction
        })

        return {
            rawResponse,
            keyId,
            keyIdBase64,
            contractId,
            signedTx: at.signed!
        }
    }

    public async createKey(app: string, user: string, settings?: {
        rpId?: string
        authenticatorSelection?: AuthenticatorSelectionCriteria
    }) {
        const now = new Date()
        const displayName = `${user} — ${now.toLocaleString()}`
        const { rpId, authenticatorSelection = {
            residentKey: "preferred",
            userVerification: "preferred",
        } } = settings || {}

        // TODO discover the contract id before creating the key so we can use it in the key name
        // TODO it's possible for the creation to fail in which case we've created a passkey but it's not onchain.
        // In this case we should save the passkey info and retry uploading it async vs asking the user to create another passkey
        // This does introduce a storage dependency though so it likely needs to be a function with some logic for choosing how to store the passkey data

        const rawResponse = await this.WebAuthn.startRegistration({
            optionsJSON: {
                challenge: base64url("stellaristhebetterblockchain"),
                rp: {
                    id: rpId,
                    name: app,
                },
                user: {
                    id: base64url(`${user}:${now.getTime()}:${Math.random()}`),
                    name: displayName,
                    displayName
                },
                authenticatorSelection,
                pubKeyCredParams: [{ alg: -7, type: "public-key" }],
            }
        });
        const { id, response } = rawResponse

        if (!this.keyId)
            this.keyId = id;

        return {
            rawResponse,
            keyId: base64url.toBuffer(id),
            keyIdBase64: id,
            publicKey: await this.getPublicKey(response),
        }
    }

    public async connectWallet(opts?: {
        rpId?: string,
        keyId?: string | Uint8Array,
        getContractId?: (keyId: string) => Promise<string | undefined>,
        // TEMP for backwards compatibility for when we seeded wallets from a factory address
        // Consider putting this somewhere else??
        walletPublicKey?: string
    }) {
        let { rpId, keyId, getContractId, walletPublicKey } = opts || {}
        let keyIdBuffer: Buffer
        let rawResponse: AuthenticationResponseJSON | undefined;

        if (!keyId) {
            rawResponse = await this.WebAuthn.startAuthentication({
                optionsJSON: {
                    challenge: base64url("stellaristhebetterblockchain"),
                    rpId,
                    userVerification: "preferred",
                }
            });

            keyId = rawResponse.id
        }

        if (keyId instanceof Uint8Array) {
            keyIdBuffer = Buffer.from(keyId)
            keyId = base64url(keyIdBuffer)
        } else {
            keyIdBuffer = base64url.toBuffer(keyId)
        }

        if (!this.keyId)
            this.keyId = keyId

        // Check for the contractId on-chain as a derivation from the keyId. This is the easiest and "cheapest" check however it will only work for the initially deployed passkey if it was used as derivation
        let contractId: string | undefined = this.encodeContract(this.walletPublicKey, keyIdBuffer);

        // attempt passkey id derivation
        try {
            // TODO what is the error if the entry exists but is archived?
            await this.rpc.getContractData(contractId, xdr.ScVal.scvLedgerKeyContractInstance())
        }
        // if that fails look up from the `getContractId` function
        catch {
            contractId = getContractId && await getContractId(keyId)
        }

        ////
        // TEMP for backwards compatibility for when we seeded wallets from a factory address
        // Consider putting this in the constructor
        if (!contractId && walletPublicKey) {
            contractId = this.encodeContract(walletPublicKey, keyIdBuffer);

            try {
                await this.rpc.getContractData(contractId, xdr.ScVal.scvLedgerKeyContractInstance())
            } catch {
                contractId = undefined
            }
        }
        ////

        if (!contractId)
            throw new Error('Failed to connect wallet')

        this.wallet = new PasskeyClient({
            contractId,
            rpcUrl: this.rpcUrl,
            networkPassphrase: this.networkPassphrase,
        })

        return {
            rawResponse,
            keyId: keyIdBuffer,
            keyIdBase64: keyId,
            contractId
        }
    }

    public async signAuthEntry(
        entry: xdr.SorobanAuthorizationEntry,
        options?: {
            rpId?: string,
            keyId?: 'any' | string | Uint8Array
            keypair?: Keypair,
            policy?: string,
            expiration?: number
        }
    ) {
        let { rpId, keyId, keypair, policy, expiration } = options || {}

        if ([keyId, keypair, policy].filter((arg) => !!arg).length > 1)
            throw new Error('Exactly one of `options.keyId`, `options.keypair`, or `options.policy` must be provided.');

        const credentials = entry.credentials().address();

        if (!expiration) {
            expiration = credentials.signatureExpirationLedger()

            if (!expiration) {
                const { sequence } = await this.rpc.getLatestLedger()
                expiration = sequence + this.timeoutInSeconds / 5; // assumes 5 second ledger time
            }
        }

        credentials.signatureExpirationLedger(expiration)

        const preimage = xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(
            new xdr.HashIdPreimageSorobanAuthorization({
                networkId: hash(Buffer.from(this.networkPassphrase)),
                nonce: credentials.nonce(),
                signatureExpirationLedger: credentials.signatureExpirationLedger(),
                invocation: entry.rootInvocation()
            })
        )

        const payload = hash(preimage.toXDR())

        // let signatures: Signatures
        let key: SDKSignerKey
        let val: Signature | undefined

        // const scSpecTypeDefSignatures = xdr.ScSpecTypeDef.scSpecTypeUdt(
        //     new xdr.ScSpecTypeUdt({ name: "Signatures" }),
        // );

        // switch (credentials.signature().switch()) {
        //     case xdr.ScValType.scvVoid():
        //         signatures = [new Map()]
        //         break;
        //     default: {
        //         signatures = this.wallet!.spec.scValToNative(credentials.signature(), scSpecTypeDefSignatures)
        //     }
        // }

        // Sign with a policy
        if (policy) {
            key = {
                tag: "Policy",
                values: [policy]
            }
            val = {
                tag: "Policy",
                values: undefined,
            }
        }

        // Sign with the keypair as an ed25519 signer
        else if (keypair) {
            const signature = keypair.sign(payload);

            key = {
                tag: "Ed25519",
                values: [keypair.rawPublicKey()]
            }
            val = {
                tag: "Ed25519",
                values: [signature],
            }
        }

        // Default, use passkey
        else {
            const authenticationResponse = await this.WebAuthn.startAuthentication({
                optionsJSON: keyId === 'any'
                    || (!keyId && !this.keyId)
                    ? {
                        challenge: base64url(payload),
                        rpId,
                        userVerification: "preferred",
                    }
                    : {
                        challenge: base64url(payload),
                        rpId,
                        allowCredentials: [
                            {
                                id: keyId instanceof Uint8Array
                                    ? base64url(Buffer.from(keyId))
                                    : keyId || this.keyId!,
                                type: "public-key",
                            },
                        ],
                        userVerification: "preferred",
                    }
            });

            key = {
                tag: "Secp256r1",
                values: [base64url.toBuffer(authenticationResponse.id)]
            }
            val = {
                tag: "Secp256r1",
                values: [
                    {
                        authenticator_data: base64url.toBuffer(
                            authenticationResponse.response.authenticatorData,
                        ),
                        client_data_json: base64url.toBuffer(
                            authenticationResponse.response.clientDataJSON,
                        ),
                        signature: this.compactSignature(
                            base64url.toBuffer(authenticationResponse.response.signature)
                        ),
                    },
                ],
            }
        }

        const scKeyType = xdr.ScSpecTypeDef.scSpecTypeUdt(
            new xdr.ScSpecTypeUdt({ name: "SignerKey" }),
        );
        const scValType = xdr.ScSpecTypeDef.scSpecTypeUdt(
            new xdr.ScSpecTypeUdt({ name: "Signature" }),
        );
        const scKey = this.wallet!.spec.nativeToScVal(key, scKeyType);
        const scVal = val ? this.wallet!.spec.nativeToScVal(val, scValType) : xdr.ScVal.scvVoid();
        const scEntry = new xdr.ScMapEntry({
            key: scKey,
            val: scVal,
        })

        switch (credentials.signature().switch().name) {
            case 'scvVoid':
                credentials.signature(xdr.ScVal.scvVec([
                    xdr.ScVal.scvMap([scEntry])
                ]))
                break;
            case 'scvVec':
                // Add the new signature to the existing map
                credentials.signature().vec()?.[0].map()?.push(scEntry)

                // Order the map by key
                // Not using Buffer.compare because Symbols are 9 bytes and unused bytes _append_ 0s vs prepending them, which is too bad
                credentials.signature().vec()?.[0].map()?.sort((a, b) => {
                    return (
                        a.key().vec()![0].sym() +
                        a.key().vec()![1].toXDR().join('')
                    ).localeCompare(
                        b.key().vec()![0].sym() +
                        b.key().vec()![1].toXDR().join('')
                    )
                })
                break;
            default:
                throw new Error('Unsupported signature')
        }

        // Insert the new signature into the signatures Map
        // signatures[0].set(key, val)

        // Insert the new signatures Map into the credentials
        // credentials.signature(
        //     this.wallet!.spec.nativeToScVal(signatures, scSpecTypeDefSignatures)
        // )

        // Order the signatures map
        // credentials.signature().vec()?.[0].map()?.sort((a, b) => {
        //     return (
        //         a.key().vec()![0].sym() +
        //         a.key().vec()![1].toXDR().join('')
        //     ).localeCompare(
        //         b.key().vec()![0].sym() +
        //         b.key().vec()![1].toXDR().join('')
        //     )
        // })

        return entry
    }

    public async sign<T>(
        txn: AssembledTransaction<T> | Tx | string,
        options?: {
            rpId?: string,
            keyId?: 'any' | string | Uint8Array
            keypair?: Keypair,
            policy?: string,
            expiration?: number
        }
    ) {
        if (!(txn instanceof AssembledTransaction)) {
            try {
                txn = AssembledTransaction.fromXDR(this.wallet!.options, typeof txn === 'string' ? txn : txn.toXDR(), this.wallet!.spec)
            } catch {
                if (!(txn instanceof AssembledTransaction)) {
                    const built = TransactionBuilder.fromXDR(typeof txn === 'string' ? txn : txn.toXDR(), this.networkPassphrase);
                    const operation = built.operations[0] as Operation.InvokeHostFunction;

                    txn = await AssembledTransaction.buildWithOp<T>(
                        Operation.invokeHostFunction({ func: operation.func }),
                        this.wallet!.options as AssembledTransactionOptions<T>
                    );
                }
            }
        }

        await txn.signAuthEntries({
            address: this.wallet!.options.contractId,
            authorizeEntry: (entry) => {
                const clone = xdr.SorobanAuthorizationEntry.fromXDR(entry.toXDR())
                return this.signAuthEntry(clone, options)
            },
        })

        return txn
    }

    public addSecp256r1(keyId: string | Uint8Array, publicKey: string | Uint8Array, limits: SignerLimits, store: SignerStore, expiration?: number) {
        return this.secp256r1(keyId, publicKey, limits, store, 'add_signer', expiration)
    }
    public addEd25519(publicKey: string, limits: SignerLimits, store: SignerStore, expiration?: number) {
        return this.ed25519(publicKey, limits, store, 'add_signer', expiration)
    }
    public addPolicy(policy: string, limits: SignerLimits, store: SignerStore, expiration?: number) {
        return this.policy(policy, limits, store, 'add_signer', expiration)
    }

    public updateSecp256r1(keyId: string | Uint8Array, publicKey: string | Uint8Array, limits: SignerLimits, store: SignerStore, expiration?: number) {
        return this.secp256r1(keyId, publicKey, limits, store, 'update_signer', expiration)
    }
    public updateEd25519(publicKey: string, limits: SignerLimits, store: SignerStore, expiration?: number) {
        return this.ed25519(publicKey, limits, store, 'update_signer', expiration)
    }
    public updatePolicy(policy: string, limits: SignerLimits, store: SignerStore, expiration?: number) {
        return this.policy(policy, limits, store, 'update_signer', expiration)
    }

    public remove(signer: SignerKey) {
        return this.wallet!.remove_signer({
            signer_key: this.getSignerKey(signer)
        }, {
            timeoutInSeconds: this.timeoutInSeconds,
        });
    }

    private secp256r1(keyId: string | Uint8Array, publicKey: string | Uint8Array, limits: SignerLimits, store: SignerStore, fn: 'add_signer' | 'update_signer', expiration?: number) {
        keyId = typeof keyId === 'string' ? base64url.toBuffer(keyId) : keyId
        publicKey = typeof publicKey === 'string' ? base64url.toBuffer(publicKey) : publicKey

        return this.wallet![fn]({
            signer: {
                tag: "Secp256r1",
                values: [
                    Buffer.from(keyId),
                    Buffer.from(publicKey),
                    [expiration],
                    this.getSignerLimits(limits),
                    { tag: store, values: undefined },
                ],
            },
        }, {
            timeoutInSeconds: this.timeoutInSeconds,
        });
    }
    private ed25519(publicKey: string, limits: SignerLimits, store: SignerStore, fn: 'add_signer' | 'update_signer', expiration?: number) {
        return this.wallet![fn]({
            signer: {
                tag: "Ed25519",
                values: [
                    Keypair.fromPublicKey(publicKey).rawPublicKey(),
                    [expiration],
                    this.getSignerLimits(limits),
                    { tag: store, values: undefined },
                ],
            },
        }, {
            timeoutInSeconds: this.timeoutInSeconds,
        });
    }
    private policy(policy: string, limits: SignerLimits, store: SignerStore, fn: 'add_signer' | 'update_signer', expiration?: number) {
        return this.wallet![fn]({
            signer: {
                tag: "Policy",
                values: [
                    policy,
                    [expiration],
                    this.getSignerLimits(limits),
                    { tag: store, values: undefined },
                ],
            },
        }, {
            timeoutInSeconds: this.timeoutInSeconds,
        });
    }

    /* LATER 
        - Add a getKeyInfo action to get info about a specific passkey
            Specifically looking for name, type, etc. data so a user could grok what signer mapped to what passkey
    */

    private getSignerLimits(limits: SignerLimits) {
        if (!limits)
            return [undefined] as SDKSignerLimits

        const sdk_limits: SDKSignerLimits = [new Map()]

        for (const [contract, signer_keys] of limits.entries()) {
            let sdk_signer_keys: SDKSignerKey[] | undefined

            if (signer_keys?.length) {
                sdk_signer_keys = []

                for (const signer_key of signer_keys) {
                    sdk_signer_keys.push(
                        this.getSignerKey(signer_key)
                    )
                }
            }

            sdk_limits[0]?.set(contract, sdk_signer_keys)
        }

        return sdk_limits
    }

    private getSignerKey({ key: tag, value }: SignerKey) {
        let signer_key: SDKSignerKey

        switch (tag) {
            case 'Policy':
                signer_key = {
                    tag,
                    values: [value]
                }
                break;
            case 'Ed25519':
                signer_key = {
                    tag,
                    values: [Keypair.fromPublicKey(value).rawPublicKey()]
                }
                break;
            case 'Secp256r1':
                signer_key = {
                    tag,
                    values: [base64url.toBuffer(value)]
                }
                break;
        }

        return signer_key
    }

    private encodeContract(walletPublicKey: string, keyIdBuffer: Buffer) {
        let contractId: string | undefined = StrKey.encodeContract(hash(xdr.HashIdPreimage.envelopeTypeContractId(
            new xdr.HashIdPreimageContractId({
                networkId: hash(Buffer.from(this.networkPassphrase)),
                contractIdPreimage: xdr.ContractIdPreimage.contractIdPreimageFromAddress(
                    new xdr.ContractIdPreimageFromAddress({
                        address: Address.fromString(walletPublicKey).toScAddress(),
                        salt: hash(keyIdBuffer),
                    })
                )
            })
        ).toXDR()));

        return contractId
    }

    private async getPublicKey(response: AuthenticatorAttestationResponseJSON) {
        let publicKey: Buffer | undefined

        if (response.publicKey) {
            publicKey = base64url.toBuffer(response.publicKey)
            publicKey = publicKey?.slice(publicKey.length - 65)
        }

        if (
            !publicKey
            || publicKey[0] !== 0x04
            || publicKey.length !== 65
        ) {
            let x: Buffer
            let y: Buffer

            if (response.authenticatorData) {
                const authenticatorData = base64url.toBuffer(response.authenticatorData)
                const credentialIdLength = (authenticatorData[53] << 8) | authenticatorData[54]

                x = authenticatorData.slice(65 + credentialIdLength, 97 + credentialIdLength)
                y = authenticatorData.slice(100 + credentialIdLength, 132 + credentialIdLength)
            } else {
                const attestationObject = base64url.toBuffer(response.attestationObject)

                let publicKeykPrefixSlice = Buffer.from([0xa5, 0x01, 0x02, 0x03, 0x26, 0x20, 0x01, 0x21, 0x58, 0x20])
                let startIndex = attestationObject.indexOf(publicKeykPrefixSlice)
                startIndex = startIndex + publicKeykPrefixSlice.length

                x = attestationObject.slice(startIndex, 32 + startIndex)
                y = attestationObject.slice(35 + startIndex, 67 + startIndex)
            }

            publicKey = Buffer.from([
                0x04, // (0x04 prefix) https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm
                ...x,
                ...y
            ])
        }

        /* TODO
            - We're doing some pretty "smart" public key decoding stuff so we should verify the signature against this final public key before assuming it's safe to use and save on-chain
                Hmm...Given that `startRegistration` doesn't produce a signature, verifying we've got the correct public key isn't really possible
            - This probably needs to be an onchain check, even if just a simulation, just to ensure everything looks good before we get too far adding value etc.
        */

        return publicKey
    }

    private compactSignature(signature: Buffer) {
        // Decode the DER signature
        let offset = 2;

        const rLength = signature[offset + 1];
        const r = signature.slice(offset + 2, offset + 2 + rLength);

        offset += 2 + rLength;

        const sLength = signature[offset + 1];
        const s = signature.slice(offset + 2, offset + 2 + sLength);

        // Convert r and s to BigInt
        const rBigInt = BigInt('0x' + r.toString('hex'));
        let sBigInt = BigInt('0x' + s.toString('hex'));

        // Ensure s is in the low-S form
        // https://github.com/stellar/stellar-protocol/discussions/1435#discussioncomment-8809175
        // https://discord.com/channels/897514728459468821/1233048618571927693
        // Define the order of the curve secp256r1
        // https://github.com/RustCrypto/elliptic-curves/blob/master/p256/src/lib.rs#L72
        const n = BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551');
        const halfN = n / 2n;

        if (sBigInt > halfN)
            sBigInt = n - sBigInt;

        // Convert back to buffers and ensure they are 32 bytes
        const rPadded = Buffer.from(rBigInt.toString(16).padStart(64, '0'), 'hex');
        const sLowS = Buffer.from(sBigInt.toString(16).padStart(64, '0'), 'hex');

        // Concatenate r and low-s
        const concatSignature = Buffer.concat([rPadded, sLowS]);

        return concatSignature;
    }
}


================================================
FILE: src/sac.ts
================================================
import { Client as SacClient } from 'sac-sdk'
import { PasskeyBase } from "./base"
import type { Server } from '@stellar/stellar-sdk/minimal/rpc'

export class SACClient extends PasskeyBase {
    declare rpc: Server
    declare rpcUrl: string

    public networkPassphrase: string
    
    constructor(options: {
        networkPassphrase: string,
        rpcUrl: string
    }) {
        const { networkPassphrase, rpcUrl } = options

        super(rpcUrl)

        this.networkPassphrase = networkPassphrase
    }

    public getSACClient(SACContractId: string) {
        return new SacClient({
            contractId: SACContractId,
            networkPassphrase: this.networkPassphrase,
            rpcUrl: this.rpcUrl,
        })
    }
}


================================================
FILE: src/server.ts
================================================
import { xdr } from "@stellar/stellar-sdk/minimal"
import { PasskeyBase } from "./base"
import base64url from "base64url"
import type { Tx } from "@stellar/stellar-sdk/minimal/contract"
import type { Signer } from "./types"
import { AssembledTransaction } from "@stellar/stellar-sdk/minimal/contract"
import { Durability } from "@stellar/stellar-sdk/minimal/rpc"
import { version } from '../package.json'

// TODO set default headers in constructor

export class PasskeyServer extends PasskeyBase {
    private launchtubeJwt: string | undefined
    private mercuryJwt: string | undefined
    private mercuryKey: string | undefined

    public launchtubeUrl: string | undefined
    public launchtubeHeaders: Record<string, string> | undefined
    public mercuryProjectName: string | undefined
    public mercuryUrl: string | undefined

    constructor(options: {
        rpcUrl?: string,
        launchtubeUrl?: string,
        launchtubeJwt?: string,
        launchtubeHeaders?: Record<string, string>
        mercuryProjectName?: string,
        mercuryUrl?: string,
        mercuryJwt?: string,
        mercuryKey?: string,
    }) {
        const {
            rpcUrl,
            launchtubeUrl,
            launchtubeJwt,
            launchtubeHeaders,
            mercuryProjectName,
            mercuryUrl,
            mercuryJwt,
            mercuryKey,
        } = options

        super(rpcUrl)

        if (launchtubeUrl)
            this.launchtubeUrl = launchtubeUrl

        if (launchtubeJwt)
            this.launchtubeJwt = launchtubeJwt

        if (launchtubeHeaders)
            this.launchtubeHeaders = launchtubeHeaders

        if (mercuryProjectName)
            this.mercuryProjectName = mercuryProjectName

        if (mercuryUrl)
            this.mercuryUrl = mercuryUrl

        if (mercuryJwt)
            this.mercuryJwt = mercuryJwt

        if (mercuryKey)
            this.mercuryKey = mercuryKey
    }

    public async getSigners(contractId: string) {
        if (!this.rpc || !this.mercuryProjectName || !this.mercuryUrl || (!this.mercuryJwt && !this.mercuryKey))
            throw new Error('Mercury service not configured')

        const signers = await fetch(`${this.mercuryUrl}/zephyr/execute`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: this.mercuryJwt ? `Bearer ${this.mercuryJwt}` : this.mercuryKey!
            },
            body: JSON.stringify({
                project_name: this.mercuryProjectName,
                mode: {
                    Function: {
                        fname: "get_signers_by_address",
                        arguments: JSON.stringify({
                            address: contractId
                        })
                    }
                }
            })
        })
            .then(async (res) => {
                if (res.ok)
                    return res.json()

                throw await res.json()
            })

        for (const signer of signers) {
            if (signer.storage === 'Temporary') {
                try {
                    await this.rpc.getContractData(contractId, xdr.ScVal.scvBytes(base64url.toBuffer(signer.key)), Durability.Temporary)
                } catch {
                    signer.evicted = true
                }
            }
        }

        return signers as Signer[]
    }

    public async getContractId(options: {
        keyId?: string,
        publicKey?: string,
        policy?: string,
    }, index = 0) {
        if (!this.mercuryProjectName || !this.mercuryUrl || (!this.mercuryJwt && !this.mercuryKey))
            throw new Error('Mercury service not configured')

        let { keyId, publicKey, policy } = options || {}

        if ([keyId, publicKey, policy].filter((arg) => !!arg).length > 1)
            throw new Error('Exactly one of `options.keyId`, `options.publicKey`, or `options.policy` must be provided.');

        let args: { key: string, kind: 'Secp256r1' | 'Ed25519' | 'Policy' }

        if (keyId)
            args = { key: keyId, kind: 'Secp256r1' }
        else if (publicKey)
            args = { key: publicKey, kind: 'Ed25519' }
        else if (policy)
            args = { key: policy, kind: 'Policy' }

        const res = await fetch(`${this.mercuryUrl}/zephyr/execute`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: this.mercuryJwt ? `Bearer ${this.mercuryJwt}` : this.mercuryKey!
            },
            body: JSON.stringify({
                project_name: this.mercuryProjectName,
                mode: {
                    Function: {
                        fname: "get_addresses_by_signer",
                        arguments: JSON.stringify(args!)
                    }
                }
            })
        })
            .then(async (res) => {
                if (res.ok)
                    return await res.json() as string[]

                throw await res.json()
            })

        return res[index]
    }

    /* LATER
        - Add a method for getting a paginated or filtered list of all a wallet's events
    */

    public async send<T>(
        txn: AssembledTransaction<T> | Tx | string, 
        fee?: number,
    ) {
        if (!this.launchtubeUrl)
            throw new Error('Launchtube service not configured')

        const data = new FormData();

        if (txn instanceof AssembledTransaction) {
            txn = txn.built!.toXDR()
        } else if (typeof txn !== 'string') {
            txn = txn.toXDR()
        }

        data.set('xdr', txn);

        if (fee)
            data.set('fee', fee.toString());

        let lt_headers = Object.assign({
            'X-Client-Name': 'passkey-kit',
            'X-Client-Version': version,
        }, this.launchtubeHeaders)

        if (this.launchtubeJwt)
            lt_headers.authorization = `Bearer ${this.launchtubeJwt}`

        return fetch(this.launchtubeUrl, {
            method: 'POST',
            headers: lt_headers,
            body: data
        }).then(async (res) => {
            if (res.ok)
            return res.json()
            else throw await res.json()
        })
    }
}


================================================
FILE: src/types.ts
================================================
export type Signer = {
    kind: string
    key: string 
    val: string 
    expiration: number | null
    storage: "Persistent" | "Temporary"
    limits: string
    evicted?: boolean 
}

export class SignerKey {
    private constructor(public key: "Policy" | "Ed25519" | "Secp256r1", public value: string) { }

    static Policy(policy: string): SignerKey {
        return new SignerKey("Policy", policy);
    }

    static Ed25519(publicKey: string): SignerKey {
        return new SignerKey("Ed25519", publicKey);
    }

    static Secp256r1(id: string): SignerKey {
        return new SignerKey("Secp256r1", id);
    }
}

export type SignerLimits = Map<string, SignerKey[] | undefined> | undefined

export enum SignerStore {
    Persistent = 'Persistent',
    Temporary = 'Temporary',
}


================================================
FILE: zephyr/Cargo.toml
================================================
[package]
name = "smart-wallets-next-dima"
version = "0.0.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
zephyr-sdk = { version = "0.2.4", git="https://github.com/xycloo/rs-zephyr-toolkit", rev="7e9e458" }
stellar-strkey = "0.0.13"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
smart-wallet-interface = { path = "../contracts/smart-wallet-interface" }
hex = "0.4.3"
base64 = "0.22.1"

[profile.release]
opt-level = "z"
overflow-checks = true
debug = 0
strip = "symbols"
debug-assertions = false
panic = "abort"
codegen-units = 1
lto = true



================================================
FILE: zephyr/rust-toolchain.toml
================================================
[toolchain]
channel = "stable-2024-09-05"
targets = ["wasm32-unknown-unknown"]
components = ["rustc", "cargo", "rustfmt", "clippy", "rust-src"]


================================================
FILE: zephyr/zephyr.toml
================================================
name = "smart-wallets-next-dima"

[[tables]]
name = "signers"
force = false

[[tables.columns]]
name = "address"
col_type = "BYTEA"
index = true

[[tables.columns]]
name = "key"
col_type = "BYTEA"
index = true

[[tables.columns]]
name = "val"
col_type = "BYTEA"

[[tables.columns]]
name = "limits"
col_type = "BYTEA"

[[tables.columns]]
name = "exp"
col_type = "BIGINT"

[[tables.columns]]
name = "storage"
col_type = "BYTEA"

[[tables.columns]]
name = "active"
col_type = "BYTEA"


================================================
FILE: zephyr/src/lib.rs
================================================
use base64::{
    engine::general_purpose::URL_SAFE, engine::general_purpose::URL_SAFE_NO_PAD, Engine as _,
};
use serde::{Deserialize, Serialize};
use smart_wallet_interface::types::{
    SignerExpiration, SignerKey, SignerLimits, SignerStorage, SignerVal,
};
use stellar_strkey::{ed25519, Strkey};
use types::{
    Signers, SignersActive, SignersAddress, SignersKeyValLimitsExpStorage,
    SignersValLimitsExpStorageActive,
};
use zephyr_sdk::{
    soroban_sdk::{
        self, symbol_short,
        xdr::{Hash, ScAddress, ScVal, ToXdr},
        Address, Bytes, BytesN, Symbol,
    },
    utils::{address_from_str, address_to_alloc_string},
    EnvClient,
};

mod types;

const SW_V1: Symbol = symbol_short!("sw_v1");
const ADD: Symbol = symbol_short!("add");
const UPDATE: Symbol = symbol_short!("update");
const REMOVE: Symbol = symbol_short!("remove");

#[no_mangle]
pub extern "C" fn on_close() {
    let env = EnvClient::new();

    for event in env.reader().pretty().soroban_events() {
        if let Some(topic0) = event.topics.get(0) {
            if let Ok(t0) = env.try_from_scval::<Symbol>(topic0) {
                if t0 == SW_V1 {
                    if let Some(topic1) = event.topics.get(1) {
                        if let Ok(t1) = env.try_from_scval::<Symbol>(topic1) {
                            if let Some(key) = event.topics.get(2) {
                                let address =
                                    ScVal::Address(ScAddress::Contract(Hash::from(event.contract)));

                                if t1 == ADD || t1 == UPDATE {
                                    let mut older: Vec<SignersValLimitsExpStorageActive> = env
                                        .read_filter()
                                        .column_equal_to_xdr("address", &address)
                                        .column_equal_to_xdr("key", key)
                                        .read()
                                        .unwrap();

                                    let (signer_val, signer_storage): (SignerVal, SignerStorage) =
                                        env.from_scval(&event.data);

                                    if let Some(older) = older.get_mut(0) {
                                        let (public_key, signer_expiration, signer_limits) =
                                            get_signer_expiration_limits(signer_val);

                                        older.val = env.to_scval(public_key);
                                        older.exp = signer_expiration.0.unwrap_or(u32::MAX);
                                        older.limits = env.to_scval(signer_limits);
                                        older.storage = env.to_scval(signer_storage);
                                        older.active = ScVal::Bool(true);

                                        env.update()
                                            .column_equal_to_xdr("address", &address)
                                            .column_equal_to_xdr("key", key)
                                            .execute(older)
                                            .unwrap();
                                    } else {
                                        let (public_key, signer_expiration, signer_limits) =
                                            get_signer_expiration_limits(signer_val);
                                        let signer = Signers {
                                            address,
                                            key: key.clone(),
                                            val: env.to_scval(public_key),
                                            limits: env.to_scval(signer_limits),
                                            exp: signer_expiration.0.unwrap_or(u32::MAX),
                                            storage: env.to_scval(signer_storage),
                                            active: ScVal::Bool(true),
                                        };

                                        env.put(&signer);
                                    }
                                } else if t1 == REMOVE {
                                    let mut older: Vec<SignersActive> = env
                                        .read_filter()
                                        .column_equal_to_xdr("address", &address)
                                        .column_equal_to_xdr("key", key)
                                        .read()
                                        .unwrap();

                                    if let Some(older) = older.get_mut(0) {
                                        older.active = ScVal::Bool(false);

                                        env.update()
                                            .column_equal_to_xdr("address", &address)
                                            .column_equal_to_xdr("key", key)
                                            .execute(older)
                                            .unwrap();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn get_signer_expiration_limits(
    signer_val: SignerVal,
) -> (Option<BytesN<65>>, SignerExpiration, SignerLimits) {
    match signer_val {
        SignerVal::Policy(signer_expiration, signer_limits) => {
            (None, signer_expiration, signer_limits)
        }
        SignerVal::Ed25519(signer_expiration, signer_limits) => {
            (None, signer_expiration, signer_limits)
        }
        SignerVal::Secp256r1(public_key, signer_expiration, signer_limits) => {
            (Some(public_key), signer_expiration, signer_limits)
        }
    }
}

#[derive(Deserialize)]
pub struct SignersByAddressRequest {
    address: String,
}

#[derive(Serialize)]
pub struct SignersByAddressResponse {
    kind: String,
    key: String,
    val: Option<String>,
    expiration: Option<u32>,
    storage: String,
    limits: String,
}

#[no_mangle]
pub extern "C" fn get_signers_by_address() {
    let env = EnvClient::empty();
    let SignersByAddressRequest { address } = env.read_request_body();

    let address = address_from_str(&env, address.as_str());
    let address = env.to_scval(address);

    let signers: Vec<SignersKeyValLimitsExpStorage> = env
        .read_filter()
        .column_equal_to_xdr("address", &address)
        .column_equal_to_xdr("active", &ScVal::Bool(true))
        .column_gt("exp", env.soroban().ledger().sequence())
        .read()
        .unwrap();

    let mut response: Vec<SignersByAddressResponse> = vec![];

    for SignersKeyValLimitsExpStorage {
        key,
        val,
        limits,
        exp,
        storage,
    } in signers
    {
        let signer_key = env.from_scval::<SignerKey>(&key);
        let signer_limits = env.from_scval::<SignerLimits>(&limits);
        let signer_storage = env.from_scval::<SignerStorage>(&storage);

        let (kind_parsed, key_parsed) = match signer_key {
            SignerKey::Policy(policy) => (
                String::from("Policy"),
                address_to_alloc_string(&env, policy),
            ),
            SignerKey::Ed25519(ed25519) => (
                String::from("Ed25519"),
                Strkey::PublicKeyEd25519(ed25519::PublicKey(ed25519.to_array())).to_string(),
            ),
            SignerKey::Secp256r1(secp256r1) => (
                String::from("Secp256r1"),
                URL_SAFE_NO_PAD.encode(secp256r1.to_alloc_vec()),
            ),
        };

        let mut val_parsed: Option<String> = None;

        if let Some(public_key) = env.from_scval::<Option<BytesN<65>>>(&val) {
            val_parsed = Some(URL_SAFE_NO_PAD.encode(public_key.to_array()));
        }

        let storage_parsed = match signer_storage {
            SignerStorage::Persistent => String::from("Persistent"),
            SignerStorage::Temporary => String::from("Temporary"),
        };

        response.push(SignersByAddressResponse {
            kind: kind_parsed,
            key: key_parsed,
            val: val_parsed,
            expiration: if exp == u32::MAX { None } else { Some(exp) },
            storage: storage_parsed,
            limits: URL_SAFE.encode(signer_limits.to_xdr(&env.soroban()).to_alloc_vec()),
        })
    }

    env.conclude(response)
}

#[derive(Deserialize)]
pub struct AddressBySignerRequest {
    key: String,
    kind: String,
}

#[no_mangle]
pub extern "C" fn get_addresses_by_signer() {
    let env = EnvClient::empty();
    let AddressBySignerRequest { key, kind } = env.read_request_body();

    let key_scval: ScVal;

    if kind == "Policy" {
        let key = address_from_str(&env, &key.as_str());
        key_scval = env.to_scval(SignerKey::Policy(key));
    } else if kind == "Ed25519" {
        // This is pretty verbose and manual but there's no easy way to go from a G-address to it's 32 bytes of public key
        let key = address_from_str(&env, &key.as_str()).to_xdr(&env.soroban());
        let key = key.slice(key.len() - 32..);
        let mut slice = [0u8; 32];
        key.copy_into_slice(&mut slice);
        let key = BytesN::from_array(&env.soroban(), &slice);
        key_scval = env.to_scval(SignerKey::Ed25519(key));
    } else if kind == "Secp256r1" {
        let key = URL_SAFE_NO_PAD.decode(key).unwrap();
        let key = Bytes::from_slice(&env.soroban(), key.as_slice());
        key_scval = env.to_scval(SignerKey::Secp256r1(key));
    } else {
        panic!("Invalid signer type");
    }

    let signers: Vec<SignersAddress> = env
        .read_filter()
        .column_equal_to_xdr("key", &key_scval)
        .column_equal_to_xdr("active", &ScVal::Bool(true))
        .read()
        .unwrap();

    if signers.is_empty() {
        env.conclude::<Vec<String>>(Vec::default());
    } else {
        let contracts = signers
            .iter()
            .map(|SignersAddress { address }| {
                address_to_alloc_string(&env, env.from_scval::<Address>(address))
            })
            .collect::<Vec<String>>();

        env.conclude(contracts);
    }
}

#[no_mangle]
pub extern "C" fn debug_signers() {
    let env = EnvClient::empty();

    let signers = env.read::<Signers>();

    env.conclude(signers);
}



================================================
FILE: zephyr/src/types.rs
================================================
use serde::Serialize;
use zephyr_sdk::{
    bincode,
    prelude::{Limits, ReadXdr, WriteXdr},
    soroban_sdk::xdr::ScVal,
    Condition, DatabaseDerive, DatabaseInteract, EnvClient, ZephyrVal,
};

#[derive(DatabaseDerive, Serialize, Clone)]
#[with_name("signers")]
pub struct Signers {
    pub address: ScVal,
    pub key: ScVal,
    pub val: ScVal,
    pub limits: ScVal,
    pub exp: u32,
    pub storage: ScVal,
    pub active: ScVal,
}

#[derive(DatabaseDerive, Serialize, Clone)]
#[with_name("signers")]
pub struct SignersKeyValLimitsExpStorage {
    pub key: ScVal,
    pub val: ScVal,
    pub limits: ScVal,
    pub exp: u32,
    pub storage: ScVal,
}

#[derive(DatabaseDerive, Serialize, Clone)]
#[with_name("signers")]
pub struct SignersValLimitsExpStorageActive {
    pub val: ScVal,
    pub limits: ScVal,
    pub exp: u32,
    pub storage: ScVal,
    pub active: ScVal,
}

#[derive(DatabaseDerive, Serialize, Clone)]
#[with_name("signers")]
pub struct SignersAddress {
    pub address: ScVal,
}

#[derive(DatabaseDerive, Serialize, Clone, Debug)]
#[with_name("signers")]
pub struct SignersActive {
    pub active: ScVal,
}



================================================
FILE: zephyr/.cargo/config.toml
================================================
[target.wasm32-unknown-unknown]
rustflags = [
    "-C", "target-feature=+multivalue",
    "-C", "link-args=-z stack-size=10000000",
]


================================================
FILE: .github/workflows/release.yml
================================================
name: Contract Release

on:
  workflow_dispatch:
    inputs:
      release_name:
        description: 'Unique release name'
        required: true
        type: string

jobs:

  release-contract-smart-wallet:
      uses: stellar-expert/soroban-build-workflow/.github/workflows/release.yml@main
      with:
        release_name: ${{ github.ref_name }}
        release_description: 'Release of the smart wallet contract'
        relative_path: 'contracts'
        package: 'smart-wallet'
      secrets:
        release_token: ${{ secrets.GITHUB_TOKEN }}


